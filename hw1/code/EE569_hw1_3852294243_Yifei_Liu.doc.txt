//(1) Name: Yifei Liu
//(2) USC ID Number: 3852294243 
//(3) USC Email: liu534@usc.edu
//(4) Submission Date: 1/22/2019

#include <stdio.h>
#include <iostream>
#include <stdlib.h>

using namespace std;

int main(int argc, char *argv[])

{
	// Define file pointer and variables
	FILE *file;
	int BytesPerPixel;
	//int Size = 256;3
	int Row;
	int Column;

	
	// Check for proper syntax
	if (argc < 3){
		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
		cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Row = 300] [Column = 390]" << endl;
		return 0;
	}
	
	// Check if image is grayscale or color
	if (argc < 4){
		BytesPerPixel = 1; // default is grey image
	} 
	else {
		BytesPerPixel = atoi(argv[3]);
		// Check if size is specified
		if (argc >= 5){
//			Size = atoi(argv[4]);
			//BytesPerPixel = atoi(argv[3]);
			Row = atoi(argv[4]);
			Column = atoi(argv[5]);
		}
	}
	
	// Allocate image data array
	unsigned char Imagedata[Row][Column][BytesPerPixel];

	// Read image (filename specified by first argument) into image data matrix
	if (!(file=fopen(argv[1],"rb"))) {
		cout << "Cannot open file: " << argv[1] <<endl;
		exit(1);
	}
	fread(Imagedata, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);
	cout << "Image read succeed!" <<endl;

	cout << "BytesPerPixel: " << BytesPerPixel <<endl;
	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////

	//1. Expand the image matrix.

	cout << "1. Expand the image matrix." <<endl;
	int N = 3; //Window size
	int i = 0;
	int j = 0;
	int k = 0;

	unsigned char Imagedata_Expassion[Row + N - 1][Column + N - 1][BytesPerPixel];

	//fill inside

	for (k = 0; k < BytesPerPixel; k++){

		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for (j = (N - 1)/2; j < Column + (N - 1)/2; j++){

				Imagedata_Expassion[i][j][k] = Imagedata[i - (N - 1)/2][j - (N - 1)/2][k];
			}
		}
	}
	cout << "Fill inside succeed!" <<endl;

	//fill the expended column.

	for (k = 0; k < BytesPerPixel; k++){

		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for (j = 0; j < (N - 1)/2 ; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[i][N - 1 - j][k];

			}
			for (j = (N - 1)/2 + Column; j < N - 1 + Column; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[i][N - 3 + 2 * Column - j][k];
			}
		}
	}
	cout << "Fill the expended column succeed!" <<endl;
	//fill the expeneded row.

	for(k = 0; k < BytesPerPixel; k++){

		for (i = 0; i < (N - 1)/2 ; i++){
			for(j = 0; j < Column + N - 1; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[N - 1 -i][j][k];
			}
		}

		for (i = (N - 1)/2 + Row; i < N - 1 + Row; i++){
			for(j = 0; j < Column + N - 1; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[N - 3 + 2 * Row - i][j][k];
			}
		}
	}


	cout << "Fill the expended row succeed!" <<endl;
	
	//2. Do demosaicing.

	cout << "2. Do demosaicing" <<endl;
	int R_channel = 0;
	int G_channel = 1;
	int B_channel = 2;
	unsigned char Imagedata_output[Row][Column][3];

	for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
		for (j = (N - 1)/2; j < Column + (N - 1)/2; j++){

			if (i % 2  == 1 && j % 2 == 1){ //Green1 pixels

				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][R_channel] = 0.5 * (Imagedata_Expassion[i][j - 1][0] + Imagedata_Expassion[i][j - 1][0]);
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][G_channel] = Imagedata_Expassion[i][j][0];
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][B_channel] = 0.5 * (Imagedata_Expassion[i - 1][j][0] + Imagedata_Expassion[i + 1][j][0]);

			}else if(i % 2 == 0 && j % 2 == 1){ //Blue pixels

				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][R_channel] = 0.25 * (Imagedata_Expassion[i - 1][j - 1][0] + Imagedata_Expassion[i + 1][j - 1][0] + Imagedata_Expassion[i - 1][j + 1][0] + Imagedata_Expassion[i + 1][j + 1][0]);
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][G_channel] = 0.25 * (Imagedata_Expassion[i - 1][j][0] + Imagedata_Expassion[i + 1][j][0] + Imagedata_Expassion[i][j - 1][0] + Imagedata_Expassion[i][j + 1][0]);
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][B_channel] = Imagedata_Expassion[i][j][0];

			}else if(i % 2 == 1 && j % 2 == 0 ){ //Red pixels

				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][R_channel] = Imagedata_Expassion[i][j][0];
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][G_channel] = 0.25 * (Imagedata_Expassion[i - 1][j][0] + Imagedata_Expassion[i + 1][j][0] + Imagedata_Expassion[i][j - 1][0] + Imagedata_Expassion[i][j + 1][0]);
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][B_channel] = 0.25 * (Imagedata_Expassion[i - 1][j - 1][0] + Imagedata_Expassion[i + 1][j - 1][0] + Imagedata_Expassion[i - 1][j + 1][0] + Imagedata_Expassion[i + 1][j + 1][0]);

			}else { //Green2 pixels

				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][R_channel] = 0.5 * (Imagedata_Expassion[i - 1][j][0] + Imagedata_Expassion[i + 1][j][0]);
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][G_channel] = Imagedata_Expassion[i][j][0];
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][B_channel] = 0.5 * (Imagedata_Expassion[i][j - 1][0] + Imagedata_Expassion[i][j - 1][0]);

			}
		}
	}

	cout << "demosaicing succeed!" <<endl;


	////////////////////////// END CODE ////////////////////////////////////////////////


	// Write image data (filename specified by second argument) from image data matrix

	if (!(file=fopen(argv[2],"wb"))) {
		cout << "Cannot open file: " << argv[2] << endl;
		exit(1);
	}
	fwrite(Imagedata_output, sizeof(unsigned char), Row*Column*3, file);
	fclose(file);

	return 0;
}

//(1) Name: Yifei Liu
//(2) USC ID Number: 3852294243 
//(3) USC Email: liu534@usc.edu
//(4) Submission Date: 1/22/2019

#include <stdio.h>
#include <iostream>
#include <stdlib.h>

using namespace std;

int convert(float num){

	if(num > 255){
		num = 255;
	}

	if(num < 0){
		num = 0;
	}
	return num;
}


int main(int argc, char *argv[])

{
	// Define file pointer and variables
	FILE *file;
	int BytesPerPixel;
	//int Size = 256;
	int Row;
	int Column;

	
	// Check for proper syntax
	if (argc < 3){
		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
		cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Row = 300] [Column = 390]" << endl;
		return 0;
	}
	
	// Check if image is grayscale or color
	if (argc < 4){
		BytesPerPixel = 1; // default is grey image
	} 
	else {
		BytesPerPixel = atoi(argv[3]);
		// Check if size is specified
		if (argc >= 5){
//			Size = atoi(argv[4]);
			//BytesPerPixel = atoi(argv[3]);
			Row = atoi(argv[4]);
			Column = atoi(argv[5]);
		}
	}
	
	// Allocate image data array
	unsigned char Imagedata[Row][Column][BytesPerPixel];

	// Read image (filename specified by first argument) into image data matrix
	if (!(file=fopen(argv[1],"rb"))) {
		cout << "Cannot open file: " << argv[1] <<endl;
		exit(1);
	}
	fread(Imagedata, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);
	cout << "Image read succeed!" <<endl;

	cout << "BytesPerPixel: " << BytesPerPixel <<endl;
	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////

	//1. Expand the image matrix.

	cout << "1. Expand the image matrix." <<endl;
	int N = 5; //Window size
	int i = 0;
	int j = 0;
	int k = 0;

	unsigned char Imagedata_Expassion[Row + N - 1][Column + N - 1][BytesPerPixel];

	//fill inside

	for (k = 0; k < BytesPerPixel; k++){

		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for (j = (N - 1)/2; j < Column + (N - 1)/2; j++){

				Imagedata_Expassion[i][j][k] = Imagedata[i - (N - 1)/2][j - (N - 1)/2][k];
			}
		}
	}
	cout << "Fill inside succeed!" <<endl;

	//fill the expended column.

	for (k = 0; k < BytesPerPixel; k++){

		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for (j = 0; j < (N - 1)/2 ; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[i][N - 1 - j][k];

			}
			for (j = (N - 1)/2 + Column; j < N - 1 + Column; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[i][N - 3 + 2 * Column - j][k];
			}
		}
	}
	cout << "Fill the expended column succeed!" <<endl;
	//fill the expeneded row.

	for(k = 0; k < BytesPerPixel; k++){

		for (i = 0; i < (N - 1)/2 ; i++){
			for(j = 0; j < Column + N - 1; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[N - 1 -i][j][k];
			}
		}

		for (i = (N - 1)/2 + Row; i < N - 1 + Row; i++){
			for(j = 0; j < Column + N - 1; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[N - 3 + 2 * Row - i][j][k];
			}
		}
	}


	cout << "Fill the expended row succeed!" <<endl;
	
	//2. Do MHC demosaicing.

	cout << "2. Do MHC demosaicing" <<endl;
	int R_channel = 0;
	int G_channel = 1;
	int B_channel = 2;
	int Imagedata_bl[Row][Column][3];
	int Delta[Row][Column][3];
	unsigned char Imagedata_output[Row][Column][3];


	for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
		for (j = (N - 1)/2; j < Column + (N - 1)/2; j++){

			if (i % 2  == 0 && j % 2 == 0){ //Green1 pixels
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][R_channel] = convert(0.125 * (5 * Imagedata_Expassion[i][j][0] + 4 * (Imagedata_Expassion[i][j - 1][0] + Imagedata_Expassion[i][j + 1][0]) - (Imagedata_Expassion[i - 1][j - 1][0] + Imagedata_Expassion[i + 1][j + 1][0] + Imagedata_Expassion[i - 1][j + 1][0] + Imagedata_Expassion[i + 1][j - 1][0] + Imagedata_Expassion[i][j - 2][0] + Imagedata_Expassion[i][j + 2][0]) + 0.5 * (Imagedata_Expassion[i - 2][j][0] + Imagedata_Expassion[i + 2][j][0])));
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][G_channel] = Imagedata_Expassion[i][j][0];
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][B_channel] = convert(0.125 * (5 * Imagedata_Expassion[i][j][0] + 4 * (Imagedata_Expassion[i - 1][j][0] + Imagedata_Expassion[i + 1][j][0]) - (Imagedata_Expassion[i - 1][j - 1][0] + Imagedata_Expassion[i + 1][j + 1][0] + Imagedata_Expassion[i - 1][j + 1][0] + Imagedata_Expassion[i + 1][j - 1][0] + Imagedata_Expassion[i - 2][j][0] + Imagedata_Expassion[i + 2][j][0]) + 0.5 * (Imagedata_Expassion[i][j - 2][0] + Imagedata_Expassion[i][j + 2][0])));


			}else if(i % 2 == 1 && j % 2 == 0){ //Blue pixels
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][R_channel] = convert(0.125 * (6 * Imagedata_Expassion[i][j][0] + 2 * (Imagedata_Expassion[i - 1][j - 1][0] + Imagedata_Expassion[i + 1][j + 1][0] + Imagedata_Expassion[i - 1][j + 1][0] + Imagedata_Expassion[i + 1][j - 1][0]) - 1.5 * (Imagedata_Expassion[i - 2][j][0] + Imagedata_Expassion[i + 2][j][0] + Imagedata_Expassion[i][j - 2][0] + Imagedata_Expassion[i][j + 2][0])));
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][G_channel] = convert(0.125 * (4 * Imagedata_Expassion[i][j][0] + 2 * (Imagedata_Expassion[i - 1][j][0] + Imagedata_Expassion[i + 1][j][0] + Imagedata_Expassion[i][j - 1][0] + Imagedata_Expassion[i][j + 1][0]) - (Imagedata_Expassion[i - 2][j][0] + Imagedata_Expassion[i + 2][j][0] + Imagedata_Expassion[i][j - 2][0] + Imagedata_Expassion[i][j + 2][0])));
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][B_channel] = Imagedata_Expassion[i][j][0];
			}else if(i % 2 == 0 && j % 2 == 1 ){ //Red pixels
				
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][R_channel] = Imagedata_Expassion[i][j][0];
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][G_channel] = convert(0.125 * (4 * Imagedata_Expassion[i][j][0] + 2 * (Imagedata_Expassion[i - 1][j][0] + Imagedata_Expassion[i + 1][j][0] + Imagedata_Expassion[i][j - 1][0] + Imagedata_Expassion[i][j + 1][0]) - (Imagedata_Expassion[i - 2][j][0] + Imagedata_Expassion[i + 2][j][0] + Imagedata_Expassion[i][j - 2][0] + Imagedata_Expassion[i][j + 2][0])));
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][B_channel] = convert(0.125 * (6 * Imagedata_Expassion[i][j][0] + 2 * (Imagedata_Expassion[i - 1][j - 1][0] + Imagedata_Expassion[i + 1][j + 1][0] + Imagedata_Expassion[i - 1][j + 1][0] + Imagedata_Expassion[i + 1][j - 1][0]) - 1.5 * (Imagedata_Expassion[i - 2][j][0] + Imagedata_Expassion[i + 2][j][0] + Imagedata_Expassion[i][j - 2][0] + Imagedata_Expassion[i][j + 2][0])));

			}else { //Green2 pixels
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][R_channel] = convert(0.125 * (5 * Imagedata_Expassion[i][j][0] + 4 * (Imagedata_Expassion[i - 1][j][0] + Imagedata_Expassion[i + 1][j][0]) - (Imagedata_Expassion[i - 1][j - 1][0] + Imagedata_Expassion[i + 1][j + 1][0] + Imagedata_Expassion[i - 1][j + 1][0] + Imagedata_Expassion[i + 1][j - 1][0] + Imagedata_Expassion[i - 2][j][0] + Imagedata_Expassion[i + 2][j][0]) + 0.5 * (Imagedata_Expassion[i][j - 2][0] + Imagedata_Expassion[i][j + 2][0])));
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][G_channel] = Imagedata_Expassion[i][j][0];
				Imagedata_output[i - (N - 1)/2][j - (N - 1)/2][B_channel] = convert(0.125 * (5 * Imagedata_Expassion[i][j][0] + 4 * (Imagedata_Expassion[i][j - 1][0] + Imagedata_Expassion[i][j + 1][0]) - (Imagedata_Expassion[i - 1][j - 1][0] + Imagedata_Expassion[i + 1][j + 1][0] + Imagedata_Expassion[i - 1][j + 1][0] + Imagedata_Expassion[i + 1][j - 1][0] + Imagedata_Expassion[i][j - 2][0] + Imagedata_Expassion[i][j + 2][0]) + 0.5 * (Imagedata_Expassion[i - 2][j][0] + Imagedata_Expassion[i + 2][j][0])));
			}
		}
	}

	cout << "demosaicing succeed!" <<endl;



    
	////////////////////////// END CODE ////////////////////////////////////////////////


	// Write image data (filename specified by second argument) from image data matrix

	if (!(file=fopen(argv[2],"wb"))) {
		cout << "Cannot open file: " << argv[2] << endl;
		exit(1);
	}
	fwrite(Imagedata_output, sizeof(unsigned char), Row*Column*3, file);
	fclose(file);

	return 0;
}

//(1) Name: Yifei Liu
//(2) USC ID Number: 3852294243 
//(3) USC Email: liu534@usc.edu
//(4) Submission Date: 1/22/2019

#include <stdio.h>
#include <iostream>
#include <stdlib.h>

using namespace std;

int main(int argc, char *argv[])

{
	// Define file pointer and variables
	FILE *file;
	int BytesPerPixel;
	//int Size = 256;
	int Row = 400;
	int Column = 400;

	
	// Check for proper syntax
	if (argc < 3){
		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
		cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Row = 400] [Column = 400]" << endl;
		return 0;
	}
	
	// Check if image is grayscale or color
	if (argc < 4){
		BytesPerPixel = 1; // default is grey image
	} 
	else {
		BytesPerPixel = atoi(argv[3]);
		// Check if size is specified
		if (argc >= 5){
//			Size = atoi(argv[4]);
			//BytesPerPixel = atoi(argv[3]);
			Row = atoi(argv[4]);
			Column = atoi(argv[5]);
		}
	}
	
	// Allocate image data array
	unsigned char Imagedata[Row][Column][BytesPerPixel];

	// Read image (filename specified by first argument) into image data matrix
	if (!(file=fopen(argv[1],"rb"))) {
		cout << "Cannot open file: " << argv[1] <<endl;
		exit(1);
	}
	fread(Imagedata, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);
	cout << "Image read succeed!" <<endl;

	cout << "BytesPerPixel: " << BytesPerPixel <<endl;
	cout << "Imagedata size:" << sizeof(Imagedata) <<endl;

	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////
	//Compute histograms
	
	int i = 0;
	int j = 0;
	int intensity_value[256] = {0};
	int Integral[256] = {0};


	for(i = 0; i < Row; i++){
		for(j = 0; j < Column; j++){

			// cout << "intensity_value: " << i << " /" << j <<" is " << intensity_value[(int)Imagedata[i][j][0]] << endl;
			intensity_value[(int)Imagedata[i][j][0]] = intensity_value[(int)Imagedata[i][j][0]] + 1;
			
		}
	}
	


	 // functions for output array to be plot
	 FILE *data_f = fopen("histogram_rosemix.txt", "w");
	 if (data_f == NULL)
	 {
	 	printf("Error opening file!\n");
	 	exit(1);
	 }
	 for (i = 0;i < 256; i++) {
	 	fprintf(data_f, "%d\n", intensity_value[i]);
	 }
	 fclose(data_f);

	

	
	//Integral

	for (i = 0; i < 256; i++){
		for (j = 0; j <= i; j++){

			Integral[i] = Integral[i] + intensity_value[j];
		}

	}

	
	
	// Plot the transfer function:
		float trans[256];
		
		for (i = 0; i < 256; i++){
			trans[i] = 255 * Integral[i] / (Row * Column);
		}
		
	 // functions for output array to be plot
	 data_f = fopen("transfunction_rosemix.txt", "w");
	 if (data_f == NULL)
	 {
	 	printf("Error opening file!\n");
	 	exit(1);
	 }
	 for (i = 0;i < 256; i++) {
	 	fprintf(data_f, "%f\n", trans[i]);
	 }
	 fclose(data_f);
		
		

	//Transfer function

	for(i = 0; i < Row; i++){
		for(j = 0; j < Column; j++){
			

			Imagedata[i][j][0] = (unsigned char)255 * Integral[(int)Imagedata[i][j][0]] / (Row * Column);
		}
	}
	
	//Caculate the modified histogram
	
	int intensity_value_plus[256] = {0};
	
	for(i = 0; i < Row; i++){
		for(j = 0; j < Column; j++){

			// cout << "intensity_value: " << i << " /" << j <<" is " << intensity_value[(int)Imagedata[i][j][0]] << endl;
			intensity_value_plus[(int)Imagedata[i][j][0]] = intensity_value_plus[(int)Imagedata[i][j][0]] + 1;
			
		}
	}
	
	 // functions for output array to be plot
	 data_f = fopen("histogram_rosemix_A.txt", "w");
	 if (data_f == NULL)
	 {
	 	printf("Error opening file!\n");
	 	exit(1);
	 }
	 for (i = 0;i < 256; i++) {
	 	fprintf(data_f, "%d\n", intensity_value_plus[i]);
	 }
	 fclose(data_f);



	// Write image data (filename specified by second argument) from image data matrix

	if (!(file=fopen(argv[2],"wb"))) {
		cout << "Cannot open file: " << argv[2] << endl;
		exit(1);
	}
	fwrite(Imagedata, sizeof(unsigned char), Row*Column*1, file);
	fclose(file);

	cout << "Write image data succeed! " <<endl; 

	return 0;
}

// This sample code reads in image data from a RAW image file and 
// writes it into another file

// NOTE:	The code assumes that the image is of size 256 x 256 and is in the
//			RAW format. You will need to make corresponding changes to
//			accommodate images of different sizes and/or types

#include <stdio.h>
#include <iostream>
#include <stdlib.h>

using namespace std;

int main(int argc, char *argv[])

{
	// Define file pointer and variables
	FILE *file;
	int BytesPerPixel;
	//int Size = 256;
	int Row = 400;
	int Column = 400;

	
	// Check for proper syntax
	if (argc < 3){
		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
		cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Row = 400] [Column = 400]" << endl;
		return 0;
	}
	
	// Check if image is grayscale or color
	if (argc < 4){
		BytesPerPixel = 1; // default is grey image
	} 
	else {
		BytesPerPixel = atoi(argv[3]);
		// Check if size is specified
		if (argc >= 5){
//			Size = atoi(argv[4]);
			//BytesPerPixel = atoi(argv[3]);
			Row = atoi(argv[4]);
			Column = atoi(argv[5]);
		}
	}
	
	// Allocate image data array
	unsigned char Imagedata[Row][Column][BytesPerPixel];

	// Read image (filename specified by first argument) into image data matrix
	if (!(file=fopen(argv[1],"rb"))) {
		cout << "Cannot open file: " << argv[1] <<endl;
		exit(1);
	}
	fread(Imagedata, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);
	cout << "Image read succeed!" <<endl;

	cout << "BytesPerPixel: " << BytesPerPixel <<endl;
	cout << "Imagedata size:" << sizeof(Imagedata) <<endl;

	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////
	//Compute histograms
	
	int i = 0;
	int j = 0;
	int k = 0;
	int intensity_value[256] = {0};
	int Integral[256] = {0};
	int Row_count[Row*Column];
	int Column_count[Row*Column];
	int m = 0;
	int n = 0;


	for(i = 0; i < Row; i++){
		for(j = 0; j < Column; j++){

			// cout << "intensity_value: " << i << " /" << j <<" is " << intensity_value[(int)Imagedata[i][j][0]] << endl;
			intensity_value[(int)Imagedata[i][j][0]] = intensity_value[(int)Imagedata[i][j][0]] + 1;
			
		}
	}
	
	
	// for (i = 0; i < 256; i++){
	// 	cout << "intensity_value: " << i << " is " << intensity_value[i] << endl;
	// }
	

	// Accumulation
	for (k = 0; k < 256; k++){
		for (i = 0; i < Row; i++){
			for(j = 0; j < Column; j++){

				if(Imagedata[i][j][0] == k){
					Row_count[m] = i;
					Column_count[m] = j;
					m = m + 1;

				}
			}
		}
	}

	n = Row * Column / 256;

	for (k = 0; k < 256 ; k++){
		for (m = k * n; m < (k + 1) * n; m++){
			Imagedata[Row_count[m]][Column_count[m]][0] = k;

		}

	}
	
	
	//Caculate the modified histogram
	
	int intensity_value_plus[256] = {0};
	
	for(i = 0; i < Row; i++){
		for(j = 0; j < Column; j++){

			// cout << "intensity_value: " << i << " /" << j <<" is " << intensity_value[(int)Imagedata[i][j][0]] << endl;
			intensity_value_plus[(int)Imagedata[i][j][0]] = intensity_value_plus[(int)Imagedata[i][j][0]] + 1;
			
		}
	}
	
	 // functions for output array to be plot
	 FILE *data_f = fopen("histogram_rosemix_B.txt", "w");
	 if (data_f == NULL)
	 {
	 	printf("Error opening file!\n");
	 	exit(1);
	 }
	 for (i = 0;i < 256; i++) {
	 	fprintf(data_f, "%d\n", intensity_value_plus[i]);
	 }
	 fclose(data_f);



	// Write image data (filename specified by second argument) from image data matrix

	if (!(file=fopen(argv[2],"wb"))) {
		cout << "Cannot open file: " << argv[2] << endl;
		exit(1);
	}
	fwrite(Imagedata, sizeof(unsigned char), Row*Column*1, file);
	fclose(file);

	cout << "Write image data succeed! " <<endl; 

	return 0;
}


//(1) Name: Yifei Liu
//(2) USC ID Number: 3852294243 
//(3) USC Email: liu534@usc.edu
//(4) Submission Date: 1/22/2019

#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <cmath>

using namespace std;

int convert(float num){

	if(num > 255){
		num = 255;
	}

	if(num < 0){
		num = 0;
	}
	return num;
}


int main(int argc, char *argv[])

{
	// Define file pointer and variables
	FILE *file;
	int BytesPerPixel;
	//int Size = 256;
	int Row;
	int Column;

	
	// Check for proper syntax
	if (argc < 4){
		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
		cout << "program_name input_image.raw ori_image.raw output_image.raw [BytesPerPixel = 1] [Row = 256] [Column = 256]" << endl;
		//cout << "program_name 1.input_image.raw 2.ori_image.raw 3.output_image_uni.raw 4.output_image_gaussian 5.[BytesPerPixel = 1] 6.[Row = 256] 7.[Column = 256]" << endl;

		return 0;
	}
	
	// Check if image is grayscale or color
	if (argc < 5){
		BytesPerPixel = 1; // default is grey image
	} 
	else {
		BytesPerPixel = atoi(argv[5]);
		// Check if size is specified
		if (argc >= 7){
//			Size = atoi(argv[4]);
			//BytesPerPixel = atoi(argv[3]);
			Row = atoi(argv[6]);
			Column = atoi(argv[7]);
		}
	}
	cout << "Row and Column: " << Row << " and" << Column <<endl;
	
	// Allocate image data array
	unsigned char Imagedata[Row][Column][BytesPerPixel];
	unsigned char Imagedata_ori[Row][Column][BytesPerPixel];

	// Read image (filename specified by first argument) into image data matrix
	if (!(file=fopen(argv[1],"rb"))) {
		cout << "Cannot open file: " << argv[1] <<endl;
		exit(1);
	}
	fread(Imagedata, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);
	cout << "Image read succeed!" <<endl;


	if (!(file=fopen(argv[2],"rb"))) {
		cout << "Cannot open file: " << argv[2] <<endl;
		exit(1);
	}
	fread(Imagedata_ori, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);

	cout << "BytesPerPixel: " << BytesPerPixel <<endl;
	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////

	//1. Expand the image matrix.

	cout << "1. Expand the image matrix." <<endl;
	int N = 11; //Window size
	int i = 0;
	int j = 0;
	int k = 0;
	int m = 0;
	int n = 0;
	int ch = 0;


	unsigned char Imagedata_Expassion[Row + N - 1][Column + N - 1][BytesPerPixel];

	//fill inside

	for (k = 0; k < BytesPerPixel; k++){

		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for (j = (N - 1)/2; j < Column + (N - 1)/2; j++){

				Imagedata_Expassion[i][j][k] = Imagedata[i - (N - 1)/2][j - (N - 1)/2][k];
			}
		}
	}
	cout << "Fill inside succeed!" <<endl;

	//fill the expended column.

	for (k = 0; k < BytesPerPixel; k++){

		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for (j = 0; j < (N - 1)/2 ; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[i][N - 1 - j][k];

			}
			for (j = (N - 1)/2 + Column; j < N - 1 + Column; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[i][N - 3 + 2 * Column - j][k];
			}
		}
	}
	cout << "Fill the expended column succeed!" <<endl;
	//fill the expeneded row.

	for(k = 0; k < BytesPerPixel; k++){

		for (i = 0; i < (N - 1)/2 ; i++){
			for(j = 0; j < Column + N - 1; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[N - 1 -i][j][k];
			}
		}

		for (i = (N - 1)/2 + Row; i < N - 1 + Row; i++){
			for(j = 0; j < Column + N - 1; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[N - 3 + 2 * Row - i][j][k];
			}
		}
	}

	

	cout << "Fill the expended row succeed!" <<endl;



	//2.Set up filters
	cout << "2.Set up filters" <<endl;


	//set up uniform weighted uniform filter
	cout << "2.1 Set up uniform weighted uniform filter" <<endl;


	double uniform_filter[N][N];

	for (i = 0; i < N;i++){
		for (j = 0; j < N; j++){

			uniform_filter[i][j] = 1.0 / (N * N);
			cout << uniform_filter[i][j]<< " ";
			if( j == N - 1){

				cout << endl;
			} 
		}
	}

	// set up gaussian filter
	cout << "2.2 Set upset up gaussian filter" <<endl;


	double gaussian_filter[N][N];
	double r;
	double sum_p;
	double sigma = 0.8;

	for (i = - (N - 1)/2; i <= (N - 1)/2; i++){
		for (j = - (N - 1)/2; j <= (N - 1)/2; j++){

			r = i*i + j*j;

			gaussian_filter[i + (N - 1)/2][j + (N - 1)/2] = exp(r / - 2 * sigma * sigma) /sqrt(2*M_PI*sigma*sigma);
			sum_p += gaussian_filter[i + (N - 1)/2][j + (N - 1)/2];

		}
	}

	for (i = 0; i < N; i++){
		for(j = 0; j < N; j++){

			gaussian_filter[i][j] = gaussian_filter[i][j]/sum_p;
			cout << gaussian_filter[i][j]<< " ";

			if( j == N - 1){

			cout << endl;
			} 

		}
	}


	//convolution by uniform filter
	cout << "3. convolution by uniform filter" <<endl;

	unsigned char Imagedata_compute_uniform[Row][Column][BytesPerPixel];
	double middle = 0.0;


	for(ch = 0; ch < BytesPerPixel; ch++){
		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for(j = (N - 1)/2; j < Column + (N - 1)/2; j++){
				middle = 0.0;
				for(m = 0; m < N; m++){	
					for(n = 0; n < N; n++){
						middle += Imagedata_Expassion[i - (N - 1)/2 + m][j - (N - 1)/2 + n][ch] * uniform_filter[m][n];
	
					}
				}
				Imagedata_compute_uniform[i - (N - 1)/2][j - (N - 1)/2][ch] = middle;
	
			}
		}
	}


	//convolution by gaussian filter
	cout << "3. convolution by gaussian_filter filter" <<endl;

	unsigned char Imagedata_compute_gaussian[Row][Column][BytesPerPixel];
	middle = 0.0;

	for(ch = 0; ch < BytesPerPixel; ch++){
		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for(j = (N - 1)/2; j < Column + (N - 1)/2; j++){
				middle = 0.0;
				for(m = 0; m < N; m++){
					for(n = 0; n < N; n++){
						middle += Imagedata_Expassion[i - (N - 1)/2 + m][j - (N - 1)/2 + n][ch] * gaussian_filter[m][n];

	
					}
				}
				Imagedata_compute_gaussian[i - (N - 1)/2][j - (N - 1)/2][ch] = (int)convert(middle);

	
			}
		}
	}





	//3. Caculate PSNR

	// compute mse
	int temp1 = 0;
	int mse1 = 0;
	double psnr1 = 0;
	int temp2 = 0;
	int mse2 = 0;
	int temp3 = 0;
	int mse3 = 0;
	double psnr2 = 0;
	double psnr3 = 0;


	for(ch = 0; ch < BytesPerPixel; ch++){
		for(i = 0; i < Row; i++){
			for (j = 0; j < Column; j++){
				temp1 = (int)Imagedata[i][j][ch] - (int)Imagedata_ori[i][j][ch];
				mse1 = mse1 + (temp1 * temp1);
	
				temp2 = (int)Imagedata_compute_uniform[i][j][ch] - (int)Imagedata_ori[i][j][ch];
				mse2 = mse2 + (temp2 * temp2);
	
				temp3 = (int)Imagedata_compute_gaussian[i][j][ch] - (int)Imagedata_ori[i][j][ch];
				mse3 = mse3 + (temp3 * temp3);
	
			}
		}
	}


	mse1 = mse1 / (Row * Column);
	mse2 = mse2 / (Row * Column);
	mse3 = mse3 / (Row * Column);

	psnr1 = 10 * log10(255.0 * 255.0 / mse1);
	psnr2 = 10 * log10(255.0 * 255.0 / mse2);
	psnr3 = 10 * log10(255.0 * 255.0 / mse3);

	cout << "psnr of noise image is :" << psnr1 <<endl;
	cout << "psnr of uniform is :" << psnr2 <<endl;
	cout << "psnr of gaussian is :" << psnr3 <<endl;


//	 //check the type of embedded noise by counting the frequency of 0-255
//	 double frequency_noi[256] = {0.0};
//	 double frequency_uni[256] = {0.0};
//	 double frequency_gau[256] = {0.0};
//
//
//	 // count the frequency of intensities
//	 int noise;
//	 int noise_uni;
//	 int noise_gau;
//	 for (i = 0; i < Row; i++) {
//	 	for (j = 0;j < Column; j++) {
//	 		noise = Imagedata[i][j][0] - Imagedata_ori[i][j][0];
//			noise_uni = Imagedata_compute_uniform[i][j][0] - Imagedata_ori[i][j][0];
//			noise_gau = Imagedata_compute_gaussian[i][j][0] - Imagedata_ori[i][j][0];
//			
//
//	 		//cout<< noise << " ";
//	 		frequency_noi[noise+100] += 1.0;
//			frequency_uni[noise_uni+100] += 1.0;
//			frequency_gau[noise_gau+100] += 1.0;
//	 	}
//	 }
//
//	 // functions for output array to be plot
//	 FILE *data_f = fopen("noise_noi.txt", "w");
//	 if (data_f == NULL)
//	 {
//	 	printf("Error opening file!\n");
//	 	exit(1);
//	 }
//	 for (i = 0;i < 256; i++) {
//	 	fprintf(data_f, "%f\n", frequency_noi[i] / (Row * Column));
//	 }
//	 fclose(data_f);
//	
//	 data_f = fopen("noise_uni.txt", "w");
//	 if (data_f == NULL)
//	 {
//	 	printf("Error opening file!\n");
//	 	exit(1);
//	 }
//	 for (i = 0;i < 256; i++) {
//	 	fprintf(data_f, "%f\n", frequency_uni[i] / (Row * Column));
//	 }
//	 fclose(data_f);
//	
//	 data_f = fopen("noise_gau.txt", "w");
//	 if (data_f == NULL)
//	 {
//	 	printf("Error opening file!\n");
//	 	exit(1);
//	 }
//	 for (i = 0;i < 256; i++) {
//	 	fprintf(data_f, "%f\n", frequency_gau[i] / (Row * Column));
//	 }
//	 fclose(data_f);
	

	////////////////////////// END CODE ////////////////////////////////////////////////


	// Write image data (filename specified by second argument) from image data matrix

	if (!(file=fopen(argv[3],"wb"))) {
		cout << "Cannot open file: " << argv[3] << endl;
		exit(1);
	}
	fwrite(Imagedata_compute_uniform, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);




	if (!(file=fopen(argv[4],"wb"))) {
		cout << "Cannot open file: " << argv[3] << endl;
		exit(1);
	}
	fwrite(Imagedata_compute_gaussian, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);

	return 0;
}

//(1) Name: Yifei Liu
//(2) USC ID Number: 3852294243 
//(3) USC Email: liu534@usc.edu
//(4) Submission Date: 1/22/2019

#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <cmath>

using namespace std;

int convert(float num){

	if(num > 255){
		num = 255;
	}

	if(num < 0){
		num = 0;
	}
	return num;
}


int main(int argc, char *argv[])

{
	// Define file pointer and variables
	FILE *file;
	int BytesPerPixel;
	//int Size = 256;
	int Row;
	int Column;

	
	// Check for proper syntax
	if (argc < 4){
		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
		cout << "program_name input_image.raw ori_image.raw output_image.raw [BytesPerPixel = 1] [Row = 256] [Column = 256]" << endl;
		//cout << "program_name 1.input_image.raw 2.ori_image.raw 3.output_image.raw 4.[BytesPerPixel = 1] 5.[Row = 256] 6.[Column = 256]" << endl;

		return 0;
	}
	
	// Check if image is grayscale or color
	if (argc < 5){
		BytesPerPixel = 1; // default is grey image
	} 
	else {
		BytesPerPixel = atoi(argv[4]);
		// Check if size is specified
		if (argc >= 6){
//			Size = atoi(argv[4]);
			//BytesPerPixel = atoi(argv[3]);
			Row = atoi(argv[5]);
			Column = atoi(argv[6]);
		}
	}
	cout << "Row and Column: " << Row << " and" << Column <<endl;
	
	// Allocate image data array
	unsigned char Imagedata[Row][Column][BytesPerPixel];
	unsigned char Imagedata_ori[Row][Column][BytesPerPixel];

	// Read image (filename specified by first argument) into image data matrix
	if (!(file=fopen(argv[1],"rb"))) {
		cout << "Cannot open file: " << argv[1] <<endl;
		exit(1);
	}
	fread(Imagedata, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);
	cout << "Image read succeed!" <<endl;


	if (!(file=fopen(argv[2],"rb"))) {
		cout << "Cannot open file: " << argv[1] <<endl;
		exit(1);
	}
	fread(Imagedata_ori, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);

	cout << "BytesPerPixel: " << BytesPerPixel <<endl;
	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////

	//1. Expand the image matrix.

	cout << "1. Expand the image matrix." <<endl;
	int N = 5; //Window size
	int i = 0;
	int j = 0;
	int l = 0;
	int k = 0;
	int ch = 0;



	unsigned char Imagedata_Expassion[Row + N - 1][Column + N - 1][BytesPerPixel];

	//fill inside

	for (k = 0; k < BytesPerPixel; k++){

		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for (j = (N - 1)/2; j < Column + (N - 1)/2; j++){

				Imagedata_Expassion[i][j][k] = Imagedata[i - (N - 1)/2][j - (N - 1)/2][k];
			}
		}
	}
	cout << "Fill inside succeed!" <<endl;

	//fill the expended column.

	for (k = 0; k < BytesPerPixel; k++){

		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for (j = 0; j < (N - 1)/2 ; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[i][N - 1 - j][k];

			}
			for (j = (N - 1)/2 + Column; j < N - 1 + Column; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[i][N - 3 + 2 * Column - j][k];
			}
		}
	}
	cout << "Fill the expended column succeed!" <<endl;
	//fill the expeneded row.

	for(k = 0; k < BytesPerPixel; k++){

		for (i = 0; i < (N - 1)/2 ; i++){
			for(j = 0; j < Column + N - 1; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[N - 1 -i][j][k];
			}
		}

		for (i = (N - 1)/2 + Row; i < N - 1 + Row; i++){
			for(j = 0; j < Column + N - 1; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[N - 3 + 2 * Row - i][j][k];
			}
		}
	}


	cout << "Fill the expended row succeed!" <<endl;



	//2.Filtering by Bilateral Filter
	cout << "2.Filtering by Bilateral Filter" <<endl;




	unsigned char Imagedata_compute_bilateral[Row][Column][BytesPerPixel];
	double middle = 0.0;
	double sigma_c = 10;
	double sigma_s = 100;
	double w;
	double w_sum = 0.0;
	double temp = 0.0;


	for(ch = 0; ch < BytesPerPixel; ch++){
		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for(j = (N - 1)/2; j < Column + (N - 1)/2; j++){
				w_sum = 0.0;
				temp = 0.0;
				for(k = i - (N - 1)/2; k < i + (N + 1) / 2; k++){
					for(l = j -(N - 1)/2; l < j + (N - 1) / 2; l++){
	
						int distance = (i - k) * (i - k) + (j - l) * (j - l);
						int luminance = abs(Imagedata_Expassion[i][j][ch] - Imagedata_Expassion[k][l][ch]);
	
						w = exp( - distance / (2 * sigma_c * sigma_c) - luminance * luminance /(2 * sigma_s * sigma_s));
						w_sum += w; 
	
						temp += Imagedata_Expassion[k][l][ch] * w;
	
					}
				}
	
				Imagedata_compute_bilateral[i - (N - 1)/2][j - (N - 1)/2][ch] = (int)convert(temp / w_sum);

	
			}
		}
	}





	//3. Caculate PSNR

	// compute mse
	double temp1 = 0;
	double mse1 = 0;
	double psnr1 = 0;
	double temp2 = 0;
	double mse2 = 0;
	double psnr2 = 0;



	for(ch = 0; ch < BytesPerPixel; ch++){
		for(i = 0; i < Row; i++){
			for (j = 0; j < Column; j++){
				temp1 = Imagedata[i][j][ch] - Imagedata_ori[i][j][ch];
				mse1 = mse1 + (temp1 * temp1);
	
				temp2 = Imagedata_compute_bilateral[i][j][ch] - Imagedata_ori[i][j][ch];
				mse2 = mse2 + (temp2 * temp2);
	
			}
		}
	}


	mse1 = mse1 / (Row * Column * BytesPerPixel);
	mse2 = mse2 / (Row * Column * BytesPerPixel);


	psnr1 = 10 * log10(255.0 * 255.0 / mse1);
	psnr2 = 10 * log10(255.0 * 255.0 / mse2);


	cout << "psnr of noise image is :" << psnr1 <<endl;
	cout << "psnr of Imagedata_compute_bilateral is :" << psnr2 <<endl;
	

	////////////////////////// END CODE ////////////////////////////////////////////////


	// Write image data (filename specified by second argument) from image data matrix

	if (!(file=fopen(argv[3],"wb"))) {
		cout << "Cannot open file: " << argv[3] << endl;
		exit(1);
	}
	fwrite(Imagedata_compute_bilateral, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);

	return 0;
}


//(1) Name: Yifei Liu
//(2) USC ID Number: 3852294243 
//(3) USC Email: liu534@usc.edu
//(4) Submission Date: 1/22/2019

#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <cmath>

using namespace std;

int main(int argc, char *argv[])

{
	// Define file pointer and variables
	FILE *file;
	int BytesPerPixel;
	//int Size = 256;
	int Row;
	int Column;

	
	// Check for proper syntax
	if (argc < 4){
		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
		cout << "program_name input_image.raw ori_image.raw output_image.raw [BytesPerPixel = 1] [Row = 256] [Column = 256]" << endl;
		//cout << "program_name 1.input_image.raw 2.ori_image.raw 3.output_image.raw 4.[BytesPerPixel = 1] 5.[Row = 256] 6.[Column = 256]" << endl;

		return 0;
	}
	
	// Check if image is grayscale or color
	if (argc < 5){
		BytesPerPixel = 1; // default is grey image
	} 
	else {
		BytesPerPixel = atoi(argv[4]);
		// Check if size is specified
		if (argc >= 6){
//			Size = atoi(argv[4]);
			//BytesPerPixel = atoi(argv[3]);
			Row = atoi(argv[5]);
			Column = atoi(argv[6]);
		}
	}
	cout << "Row and Column: " << Row << " and" << Column <<endl;
	
	// Allocate image data array
	unsigned char Imagedata[Row][Column][BytesPerPixel];
	unsigned char Imagedata_ori[Row][Column][BytesPerPixel];

	// Read image (filename specified by first argument) into image data matrix
	if (!(file=fopen(argv[1],"rb"))) {
		cout << "Cannot open file: " << argv[1] <<endl;
		exit(1);
	}
	fread(Imagedata, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);
	cout << "Image read succeed!" <<endl;


	if (!(file=fopen(argv[2],"rb"))) {
		cout << "Cannot open file: " << argv[1] <<endl;
		exit(1);
	}
	fread(Imagedata_ori, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);

	cout << "BytesPerPixel: " << BytesPerPixel <<endl;
	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////

	//1. Expand the image matrix.

	cout << "1. Expand the image matrix." <<endl;
	int N = 3; //Window size
	int i = 0;
	int j = 0;
	int l = 0;
	int k = 0;
	int ch = 0;



	unsigned char Imagedata_Expassion[Row + N - 1][Column + N - 1][BytesPerPixel];

	//fill inside

	for (k = 0; k < BytesPerPixel; k++){

		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for (j = (N - 1)/2; j < Column + (N - 1)/2; j++){

				Imagedata_Expassion[i][j][k] = Imagedata[i - (N - 1)/2][j - (N - 1)/2][k];
			}
		}
	}
	cout << "Fill inside succeed!" <<endl;

	//fill the expended column.

	for (k = 0; k < BytesPerPixel; k++){

		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for (j = 0; j < (N - 1)/2 ; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[i][N - 1 - j][k];

			}
			for (j = (N - 1)/2 + Column; j < N - 1 + Column; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[i][N - 3 + 2 * Column - j][k];
			}
		}
	}
	cout << "Fill the expended column succeed!" <<endl;
	//fill the expeneded row.

	for(k = 0; k < BytesPerPixel; k++){

		for (i = 0; i < (N - 1)/2 ; i++){
			for(j = 0; j < Column + N - 1; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[N - 1 -i][j][k];
			}
		}

		for (i = (N - 1)/2 + Row; i < N - 1 + Row; i++){
			for(j = 0; j < Column + N - 1; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[N - 3 + 2 * Row - i][j][k];
			}
		}
	}

	 

	cout << "Fill the expended row succeed!" <<endl;



	//convolution by uniform filter
	cout << "2. convolution by non_local_mean filter" <<endl;

	unsigned char Imagedata_compute_non_local_mean[Row][Column][BytesPerPixel];
	float middle = 0.0;
	float h = 100;
	float w;
	float w_sum = 0.0;
	float temp = 0.0;
	int M1 = 3;
	int M2 = 3;
	int n1 = 0;
	int n2 = 0;
	float a = 1;


	for (ch = 0;ch < BytesPerPixel; ch++){
		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for(j = (N - 1)/2; j < Column + (N - 1)/2; j++){
	
				float f_sum = 0.0;
				float I_f_sum = 0.0;
				for(k = max(i - M1,(N - 1)/2); k <= min(i + M1,Row + (N - 1)/2 - 1); k++){
					for(l = max(j - M2,(N - 1)/2); l <= min(j + M2,Column + (N - 1)/2 - 1); l++){
						float gaussian_distance = 0.0;
						for (n1 = - (N - 1)/2; n1 <= (N - 1)/2; n1++){
							for(n2 = - (N - 1)/2; n2 <= (N - 1)/2; n2++){
	
								float gaussian_parameter = exp(- (n1*n1 + n2*n2)/(2*a*a)) / (sqrt(2 * M_PI) * a);
								gaussian_distance += gaussian_parameter * pow(Imagedata_Expassion[i + n1][j + n2][ch] - Imagedata_Expassion[k + n1][l + n2][ch],2);
	
							}
						}
	
						float f = exp( - gaussian_distance / (h*h));
						f_sum += f;
						I_f_sum += Imagedata_Expassion[k][l][ch] * f;
	
					}
				}
	
				Imagedata_compute_non_local_mean[i - (N - 1)/2][j - (N - 1)/2][ch] = (int)I_f_sum / f_sum;

			}
		}
	}





	//3. Caculate PSNR

	// compute mse
	int temp1 = 0;
	double mse1 = 0;
	double psnr1 = 0;
	int temp2 = 0;
	double mse2 = 0;
	double psnr2 = 0;



	for(ch = 0; ch < BytesPerPixel; ch++){
		for(i = 0; i < Row; i++){
			for (j = 0; j < Column; j++){
				temp1 = (int)Imagedata[i][j][ch] - (int)Imagedata_ori[i][j][ch];
				mse1 = mse1 + (unsigned int)(temp1 * temp1);
	
				temp2 = (int)Imagedata_compute_non_local_mean[i][j][ch] - (int)Imagedata_ori[i][j][ch];
				mse2 = mse2 + (unsigned int)(temp2 * temp2);
	
			}
		}
	}

	mse1 = mse1 / (Row * Column * BytesPerPixel);
	mse2 = mse2 / (Row * Column * BytesPerPixel);

	psnr1 = 10 * log10(255.0 * 255.0 / mse1);
	psnr2 = 10 * log10(255.0 * 255.0 / mse2);


	cout << "psnr of noise image is :" << psnr1 <<endl;
	cout << "psnr of non_local_mean is :" << psnr2 <<endl;


	// //check the type of embedded noise by counting the frequency of 0-255
	// float frequency[256] = {0.0};

	// // count the frequency of intensities
	// int noise;
	// for (i = 0; i < Row; i++) {
	// 	for (j = 0;j < Column; j++) {
	// 		noise = Imagedata[i][j][0] - Imagedata_ori[i][j][0];

	// 		//cout<< noise << " ";
	// 		frequency[noise+100] += 1.0;
	// 	}
	// }

	// // functions for output array to be plot
	// FILE *data_f = fopen("noise_distribution.txt", "w");
	// if (data_f == NULL)
	// {
	// 	printf("Error opening file!\n");
	// 	exit(1);
	// }
	// for (i = 0;i < 256; i++) {
	// 	fprintf(data_f, "%f\n", frequency[i] / (Row * Column));
	// }
	// fclose(data_f);
	

	////////////////////////// END CODE ////////////////////////////////////////////////


	// Write image data (filename specified by second argument) from image data matrix

	if (!(file=fopen(argv[3],"wb"))) {
		cout << "Cannot open file: " << argv[3] << endl;
		exit(1);
	}
	fwrite(Imagedata_compute_non_local_mean, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);

	return 0;
}

//(1) Name: Yifei Liu
//(2) USC ID Number: 3852294243 
//(3) USC Email: liu534@usc.edu
//(4) Submission Date: 1/22/2019

#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <cmath>

using namespace std;

int main(int argc, char *argv[])

{
	// Define file pointer and variables
	FILE *file;
	int BytesPerPixel;
	//int Size = 256;
	int Row;
	int Column;

	
	// Check for proper syntax
	if (argc < 4){
		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
		cout << "program_name input_image.raw ori_image.raw output_image.raw [BytesPerPixel = 1] [Row = 256] [Column = 256]" << endl;
		//cout << "program_name 1.input_image.raw 2.ori_image.raw 3.output_image.raw 4.[BytesPerPixel = 1] 5.[Row = 256] 6.[Column = 256]" << endl;

		return 0;
	}
	
	// Check if image is grayscale or color
	if (argc < 5){
		BytesPerPixel = 1; // default is grey image
	} 
	else {
		BytesPerPixel = atoi(argv[4]);
		// Check if size is specified
		if (argc >= 6){
//			Size = atoi(argv[4]);
			//BytesPerPixel = atoi(argv[3]);
			Row = atoi(argv[5]);
			Column = atoi(argv[6]);
		}
	}
	cout << "Row and Column: " << Row << " and" << Column <<endl;
	
	// Allocate image data array
	unsigned char Imagedata[Row][Column][BytesPerPixel];
	unsigned char Imagedata_ori[Row][Column][BytesPerPixel];

	// Read image (filename specified by first argument) into image data matrix
	if (!(file=fopen(argv[1],"rb"))) {
		cout << "Cannot open file: " << argv[1] <<endl;
		exit(1);
	}
	fread(Imagedata, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);
	cout << "Image read succeed!" <<endl;


	if (!(file=fopen(argv[2],"rb"))) {
		cout << "Cannot open file: " << argv[1] <<endl;
		exit(1);
	}
	fread(Imagedata_ori, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);

	cout << "BytesPerPixel: " << BytesPerPixel <<endl;
	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////

	//1. Expand the image matrix.

	cout << "1. Expand the image matrix." <<endl;
	int N = 5; //Window size
	int i = 0;
	int j = 0;
	int l = 0;
	int k = 0;
	int ch = 0;



	unsigned char Imagedata_Expassion[Row + N - 1][Column + N - 1][BytesPerPixel];

	//fill inside

	for (k = 0; k < BytesPerPixel; k++){

		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for (j = (N - 1)/2; j < Column + (N - 1)/2; j++){

				Imagedata_Expassion[i][j][k] = Imagedata[i - (N - 1)/2][j - (N - 1)/2][k];
			}
		}
	}
	cout << "Fill inside succeed!" <<endl;

	//fill the expended column.

	for (k = 0; k < BytesPerPixel; k++){

		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for (j = 0; j < (N - 1)/2 ; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[i][N - 1 - j][k];

			}
			for (j = (N - 1)/2 + Column; j < N - 1 + Column; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[i][N - 3 + 2 * Column - j][k];
			}
		}
	}
	cout << "Fill the expended column succeed!" <<endl;
	//fill the expeneded row.

	for(k = 0; k < BytesPerPixel; k++){

		for (i = 0; i < (N - 1)/2 ; i++){
			for(j = 0; j < Column + N - 1; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[N - 1 -i][j][k];
			}
		}

		for (i = (N - 1)/2 + Row; i < N - 1 + Row; i++){
			for(j = 0; j < Column + N - 1; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[N - 3 + 2 * Row - i][j][k];
			}
		}
	}



	cout << "Fill the expended row succeed!" <<endl;



	//2. Filtering by Midian Filter
	cout << "2.Filtering by Midian Filter" <<endl;


	unsigned char Imagedata_compute_median[Row][Column][BytesPerPixel];

	unsigned char mediansort[N*N];
	


	for(ch = 0; ch < BytesPerPixel; ch++){
		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for(j = (N - 1)/2; j < Column + (N - 1)/2; j++){
				int a = 0;
				for(k = i - (N - 1)/2; k < i + (N + 1) / 2; k++){
					for(l = j -(N - 1)/2; l < j + (N - 1) / 2; l++){

						mediansort[a] = Imagedata_Expassion[k][l][ch];
						a++;

					}
				}
				

				sort(mediansort, mediansort + N*N);

	
				Imagedata_compute_median[i - (N - 1)/2][j - (N - 1)/2][ch] = mediansort[(N*N - 1) / 2];

			}
		}
	}





	//3. Caculate PSNR

	// compute mse
	double temp1 = 0;
	double mse1 = 0;
	double psnr1 = 0;
	double temp2 = 0;
	double mse2 = 0;
	double psnr2 = 0;




	for(ch = 0; ch < BytesPerPixel; ch++){
		for(i = 0; i < Row; i++){
			for (j = 0; j < Column; j++){
				temp1 = Imagedata[i][j][ch] - Imagedata_ori[i][j][ch];
				mse1 = mse1 + (temp1 * temp1);
	
				temp2 = Imagedata_compute_median[i][j][ch] - Imagedata_ori[i][j][ch];
				mse2 = mse2 + (temp2 * temp2);
	
			}
		}
	}


	mse1 = mse1 / (Row * Column * BytesPerPixel);
	mse2 = mse2 / (Row * Column * BytesPerPixel);


	psnr1 = 10 * log10(255.0 * 255.0 / mse1);
	psnr2 = 10 * log10(255.0 * 255.0 / mse2);


	cout << "psnr of noise image is :" << psnr1 <<endl;
	cout << "psnr of Imagedata_compute_median  is :" << psnr2 <<endl;
	

	////////////////////////// END CODE ////////////////////////////////////////////////


	// Write image data (filename specified by second argument) from image data matrix

	if (!(file=fopen(argv[3],"wb"))) {
		cout << "Cannot open file: " << argv[3] << endl;
		exit(1);
	}
	fwrite(Imagedata_compute_median, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);

	return 0;
}

//(1) Name: Yifei Liu
//(2) USC ID Number: 3852294243 
//(3) USC Email: liu534@usc.edu
//(4) Submission Date: 1/22/2019
#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <cmath>

using namespace std;

double convert(float num){

	if(num > 255){
		num = 255;
	}

	if(num < 0){
		num = 0;
	}
	return num;
}


int main(int argc, char *argv[])

{
	// Define file pointer and variables
	FILE *file;
	int BytesPerPixel;
	//int Size = 256;
	int Row;
	int Column;

	
	// Check for proper syntax
	if (argc < 4){
		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
		cout << "program_name input_image.raw ori_image.raw output_image.raw [BytesPerPixel = 1] [Row = 256] [Column = 256]" << endl;
		//cout << "program_name 1.input_image.raw 2.ori_image.raw 3.output_image.raw (biased) 4.output_image.raw (unbiased) 5.[BytesPerPixel = 1] 6.[Row = 256] 7.[Column = 256]" << endl;

		return 0;
	}
	
	// Check if image is grayscale or color
	if (argc < 5){
		BytesPerPixel = 1; // default is grey image
	} 
	else {
		BytesPerPixel = atoi(argv[5]);
		// Check if size is specified
		if (argc >= 7){
//			Size = atoi(argv[4]);
			//BytesPerPixel = atoi(argv[3]);
			Row = atoi(argv[6]);
			Column = atoi(argv[7]);
		}
	}
	cout << "Row and Column: " << Row << " and" << Column <<endl;
	
	// Allocate image data array
	unsigned char Imagedata[Row][Column][BytesPerPixel];
	unsigned char Imagedata_ori[Row][Column][BytesPerPixel];

	// Read image (filename specified by first argument) into image data matrix
	if (!(file=fopen(argv[1],"rb"))) {
		cout << "Cannot open file: " << argv[1] <<endl;
		exit(1);
	}
	fread(Imagedata, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);
	cout << "Image read succeed!" <<endl;


	if (!(file=fopen(argv[2],"rb"))) {
		cout << "Cannot open file: " << argv[1] <<endl;
		exit(1);
	}
	fread(Imagedata_ori, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);

	cout << "BytesPerPixel: " << BytesPerPixel <<endl;
	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////
	int N = 3; //Window size
	int i = 0;
	int j = 0;
	int l = 0;
	int k = 0;
	int ch = 0;

	
	
	cout << "1. Transform Image" <<endl;

	double Imagedata_Transformed[Row][Column][BytesPerPixel];



	for(ch = 0; ch < BytesPerPixel; ch++){
		for (i = 0; i < Row; i++){
			for (j = 0; j < Column; j++){

				Imagedata_Transformed[i][j][ch] =  2 * sqrt(Imagedata[i][j][ch] + 3.0 / 8.0);
			}
		}
	}

	

	//1. Expand the image matrix.

	cout << "2. Expand the image matrix." <<endl;




	double Imagedata_Expassion[Row + N - 1][Column + N - 1][BytesPerPixel];

	//fill inside

	for (k = 0; k < BytesPerPixel; k++){

		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for (j = (N - 1)/2; j < Column + (N - 1)/2; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Transformed[i - (N - 1)/2][j - (N - 1)/2][k];
			}
		}
	}
	cout << "Fill inside succeed!" <<endl;

	//fill the expended column.

	for (k = 0; k < BytesPerPixel; k++){

		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for (j = 0; j < (N - 1)/2 ; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[i][N - 1 - j][k];

			}
			for (j = (N - 1)/2 + Column; j < N - 1 + Column; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[i][N - 3 + 2 * Column - j][k];
			}
		}
	}
	cout << "Fill the expended column succeed!" <<endl;
	//fill the expeneded row.

	for(k = 0; k < BytesPerPixel; k++){

		for (i = 0; i < (N - 1)/2 ; i++){
			for(j = 0; j < Column + N - 1; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[N - 1 -i][j][k];
			}
		}

		for (i = (N - 1)/2 + Row; i < N - 1 + Row; i++){
			for(j = 0; j < Column + N - 1; j++){

				Imagedata_Expassion[i][j][k] = Imagedata_Expassion[N - 3 + 2 * Row - i][j][k];
			}
		}
	}

	 

	cout << "Fill the expended row succeed!" <<endl;




	cout << "3. Set upset up gaussian filter" <<endl;


	double gaussian_filter[N][N];
	double r;
	double sum_p;
	double sigma = 1;

	for (i = - (N - 1)/2; i <= (N - 1)/2; i++){
		for (j = - (N - 1)/2; j <= (N - 1)/2; j++){

			r = i*i + j*j;

			gaussian_filter[i + (N - 1)/2][j + (N - 1)/2] = exp(- r / 2 * sigma * sigma);
			sum_p += gaussian_filter[i + (N - 1)/2][j + (N - 1)/2];

		}
	}

	for (i = 0; i < N; i++){
		for(j = 0; j < N; j++){

			gaussian_filter[i][j] = gaussian_filter[i][j]/sum_p;
			cout << gaussian_filter[i][j]<< " ";

			if( j == N - 1){

			cout << endl;
			} 

		}
	}

	cout << "4. convolution by gaussian filter" <<endl;

	double Imagedata_compute_gaussian[Row][Column][BytesPerPixel];
	double middle = 0.0;
	int m;
	int n;


	for(ch = 0; ch < BytesPerPixel; ch++){
		for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
			for(j = (N - 1)/2; j < Column + (N - 1)/2; j++){
				middle = 0.0;
				for(m = 0; m < N; m++){	
					for(n = 0; n < N; n++){
						
						middle += Imagedata_Expassion[i - (N - 1)/2 + m][j - (N - 1)/2 + n][ch] * gaussian_filter[m][n];
	
					}
				}
				Imagedata_compute_gaussian[i - (N - 1)/2][j - (N - 1)/2][ch] = convert(middle);

			}
		}
	}




	 cout << "5. Inverse Transform Image (biased)" <<endl;
	 unsigned char Imagedata_output_biased[Row][Column][BytesPerPixel];

	 for(ch = 0; ch < BytesPerPixel; ch++){
	 	for (i = 0; i < Row; i++){
	 		for (j = 0; j < Column; j++){

	 			Imagedata_output_biased[i][j][ch] = pow(Imagedata_compute_gaussian[i][j][ch],2) / 4.0 - 3.0 / 8.0;
	 		}
	 	}
	 }

	cout << "6. Inverse Transform Image (unbiased)" <<endl;
	unsigned char Imagedata_output_unbiased[Row][Column][BytesPerPixel];


	for(ch = 0; ch < BytesPerPixel; ch++){
		for (i = 0; i < Row; i++){
			for (j = 0; j < Column; j++){

				Imagedata_output_unbiased[i][j][ch] = pow(Imagedata_compute_gaussian[i][j][ch],2)/4.0 - 1.0 / 8.0;
			}
		}
	}

		




	//3. Caculate PSNR

	// compute mse
	double temp1 = 0;
	double mse1 = 0;
	double psnr1 = 0;
	double temp2 = 0;
	double mse2 = 0;
	double psnr2 = 0;
	double temp3 = 0;
	double mse3 = 0;
	double psnr3 = 0;



	for(ch = 0; ch < BytesPerPixel; ch++){
		for(i = 0; i < Row; i++){
			for (j = 0; j < Column; j++){
				temp1 = Imagedata[i][j][ch] - Imagedata_ori[i][j][ch];
				mse1 = mse1 + (temp1 * temp1);
	
				temp2 = Imagedata_output_biased[i][j][ch] - Imagedata_ori[i][j][ch];
				mse2 = mse2 + (temp2 * temp2);
				
				temp3 = Imagedata_output_unbiased[i][j][ch] - Imagedata_ori[i][j][ch];
				mse3 = mse3 + (temp3 * temp3);
	
			}
		}
	}

	mse1 = mse1 / (Row * Column * BytesPerPixel);
	mse2 = mse2 / (Row * Column * BytesPerPixel);
	mse3 = mse3 / (Row * Column * BytesPerPixel);

	psnr1 = 10 * log10(255.0 * 255.0 / mse1);
	psnr2 = 10 * log10(255.0 * 255.0 / mse2);
	psnr3 = 10 * log10(255.0 * 255.0 / mse3);


	cout << "psnr of noise image is :" << psnr1 <<endl;
	cout << "psnr of denoised(biased) is :" << psnr2 <<endl;
	cout << "psnr of denoised(unbiased) is :" << psnr2 <<endl;
	
	
//	 // 4. count the frequency of intensities
//	 int noise;
//	 int noise_trans;
//	 int noise_output;
//	 double frequency_shot[256] = {0.0};
//	 double frequency_gau[256] = {0.0};
//	 double frequency_output[256] = {0.0};
//	 for (i = 0; i < Row; i++) {
//	 	for (j = 0;j < Column; j++) {
//	 		noise = Imagedata[i][j][0] - Imagedata_ori[i][j][0];
//			noise_trans = Imagedata_Transformed[i][j][0] - Imagedata_ori[i][j][0];	
//			noise_output = Imagedata_output[i][j][0] - Imagedata_ori[i][j][0];	
//
//	 		//cout<< noise << " ";
//	 		frequency_shot[noise+200] += 1.0;
//	 		frequency_gau[noise_trans+200] += 1.0;
//	 		frequency_output[noise_output+200] += 1.0;
//
//	 	}
//	 }
//
//	 // functions for output array to be plot
//	 FILE *data_f = fopen("shot_noise.txt", "w");
//	 if (data_f == NULL)
//	 {
//	 	printf("Error opening file!\n");
//	 	exit(1);
//	 }
//	 for (i = 0;i < 256; i++) {
//	 	fprintf(data_f, "%f\n", frequency_shot[i] / (Row * Column));
//	 }
//	 fclose(data_f);
//	
//	 // functions for output array to be plot
//	 data_f = fopen("shot_noise_trans.txt", "w");
//	 if (data_f == NULL)
//	 {
//	 	printf("Error opening file!\n");
//	 	exit(1);
//	 }
//	 for (i = 0;i < 256; i++) {
//	 	fprintf(data_f, "%f\n", frequency_gau[i] / (Row * Column));
//	 }
//	 fclose(data_f);
//	
//	 // functions for output array to be plot
//	 data_f = fopen("shot_noise_denoised.txt", "w");
//	 if (data_f == NULL)
//	 {
//	 	printf("Error opening file!\n");
//	 	exit(1);
//	 }
//	 for (i = 0;i < 256; i++) {
//	 	fprintf(data_f, "%f\n", frequency_output[i] / (Row * Column));
//	 }
//	 fclose(data_f);


	////////////////////////// END CODE ////////////////////////////////////////////////


	// Write image data (filename specified by second argument) from image data matrix

	if (!(file=fopen(argv[3],"wb"))) {
		cout << "Cannot open file: " << argv[3] << endl;
		exit(1);
	}
	fwrite(Imagedata_output_biased, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);

	if (!(file=fopen(argv[4],"wb"))) {
		cout << "Cannot open file: " << argv[3] << endl;
		exit(1);
	}
	fwrite(Imagedata_output_unbiased, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
	fclose(file);

	return 0;
}
