#//(1) Name: Yifei Liu
#//(2) USC ID Number: 3852294243 
#//(3) USC Email: liu534@usc.edu
#//(4) Submission Date: 3/3/2019

import cv2
from matplotlib import pyplot as plt
import numpy as np
import math
import rawpy
import imageio

def Findvertices(img1):
	vertices_right = []
	vertices_left = []
	vertices_up = []
	vertices_down = []
	
	temp_right_i = 0
	temp_right_j = 0
	temp_left_i = 0
	temp_left_j = img1.shape[1]
	temp_up_i = img1.shape[0]
	temp_up_j = 0
	temp_down_i = 0
	temp_down_j = 0
	p = 4
	for i in range(img1.shape[0]):
		for j in range(img1.shape[1]):

			if img1[i][j] != 255:
				
				if img1[i-p][j] == 255 and img1[i+p][j] == 255 and img1[i][j+p] == 255: #right
					if j > temp_right_j:
						temp_right_i = i
						temp_right_j = j
				elif img1[i-p][j] == 255 and img1[i+p][j] == 255 and img1[i][j-p] == 255: #left
					if j < temp_left_j:
						temp_left_i = i
						temp_left_j = j
				elif img1[i][j-p] == 255 and img1[i][j+p] == 255 and img1[i-p][j] == 255: #up 
					if i < temp_up_i:
						temp_up_i = i
						temp_up_j = j

				elif img1[i][j-p] == 255 and img1[i][j+p] == 255 and img1[i+p][j] == 255: #down
					if i > temp_down_i:
						temp_down_i = i
						temp_down_j = j

	vertices_right.append(temp_right_i)
	vertices_right.append(temp_right_j)
	vertices_left.append(temp_left_i)
	vertices_left.append(temp_left_j)
	vertices_up.append(temp_up_i)
	vertices_up.append(temp_up_j)
	vertices_down.append(temp_down_i)
	vertices_down.append(temp_down_j)
		
	return vertices_right,vertices_left,vertices_up,vertices_down
	
def findhull(img):
	
	for i in range(img.shape[0]):
		for j in range(img.shape[1]):
			if img[i][j] < 255:
				img[i][j] = 0;
			else:
				img[i][j] = 1

				
	vertices_right_up = []
	vertices_left_up = []
	vertices_right_down = []
	vertices_left_down = []
	
	Window_leftup = np.array([[0,0,0,0,0],[0,0,0,0,0],[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1]])
	Window_leftdown = np.array([[0,0,1,1,1],[0,0,1,1,1],[0,0,1,1,1],[0,0,0,0,0],[0,0,0,0,0]])
	Window_rightup = np.array([[0,0,0,0,0],[0,0,0,0,0],[1,1,1,0,0],[1,1,1,0,0],[1,1,1,0,0]])
	Window_rightdown = np.array([[1,1,1,0,0],[1,1,1,0,0],[1,1,1,0,0],[0,0,0,0,0],[0,0,0,0,0]])
	
#	print("Window_leftup:\n",Window_leftup)
	

	for i in range(2,img.shape[0]-2):
		for j in range(2,img.shape[1]-2):
			if img[i][j] == 1:
#				print(img[i-2:i+3,j-2:j+3])
				
#				print(sum(sum(np.dot(Window_leftup,img[i-2:i+3,j-2:j+3]))))
				
				if  np.array_equal(Window_leftup,img[i-2:i+3,j-2:j+3]):
					vertices_left_up.append(i)
					vertices_left_up.append(j)
#					print("Find Left up Vertix!")
				elif np.array_equal(Window_leftdown,img[i-2:i+3,j-2:j+3]):
					vertices_left_down.append(i)
					vertices_left_down.append(j)
#					print("Find Left down Vertix!")
				elif np.array_equal(Window_rightup,img[i-2:i+3,j-2:j+3]):
					vertices_right_up.append(i)
					vertices_right_up.append(j)
#					print("Find Right up Vertix!")
				elif np.array_equal(Window_rightdown,img[i-2:i+3,j-2:j+3]):
					vertices_right_down.append(i)
					vertices_right_down.append(j)
#					print("Find Right down Vertix!")
					

			
	return vertices_right_up, vertices_left_up, vertices_right_down, vertices_left_down
		
def caculate_paras(right,left,up,down):
	theta = []
	central_i = []
	central_j = []
	width = []
	height = []
	central = np.zeros((2,))
	
	width.append(np.sqrt((left[0] - up[0])**2 + (left[1] - up[1])**2))
	width.append(np.sqrt((right[0] - down[0])**2 + (right[1] - down[1])**2))
	
	height.append(np.sqrt((left[0] - down[0])**2 + (left[1] - down[1])**2))
	height.append(np.sqrt((right[0] - up[0])**2 + (right[1] - up[1])**2))
	
	central_i.append((left[0]+right[0])/2)
	central_i.append((up[0] + down[0])/2)
	central_j.append((left[1]+right[1])/2)
	central_j.append((up[1] + down[1])/2)
	central[0] = np.mean(central_i)
	central[1] = np.mean(central_j)
	
	theta.append(np.arctan((down[0] - left[0])/(down[1] - left[1])))
	theta.append(np.arctan((right[0] - up[0])/(right[1] - up[1])))
	theta.append(np.arctan((up[1] - left[1])/(left[0] - up[0])))
	theta.append(np.arctan((right[1] - down[1])/(down[0] - right[0])))
	
	return np.mean(width), np.mean(height), central, np.mean(theta)
	
	
def Image_to_cartesian(img,i,j):
	index = np.array([[i+1],[j+1],[1]])
	cartesian = np.zeros((3,1))
	mtx = np.array([[0,1,-0.5],[-1,0,img.shape[0]+0.5],[0,0,1]])
	cartesian = mtx @ index
	
#	print(cartesian)
	return cartesian

def cartesian_to_Image(img,cartesian):
	idx = np.zeros((3,1))
	mtx = np.array([[0,-1,img.shape[0]+0.5],[1,0,0.5],[0,0,1]])
	idx = mtx @ cartesian - [[1],[1],[0]]
	
	if idx[0] > img.shape[0] - 1:
		idx[0] = img.shape[0] - 1
	elif idx[0] < 0:
		idx[0] = 0
		
	if idx[1] > img.shape[1] - 1:
		idx[1] = img.shape[1] - 1
	elif idx[1] < 0:
		idx[1] = 0
		
#	print("idx:\n",idx)
	return idx


def caculate_rotation_mtx(img, theta, central):
	central = Image_to_cartesian(img, central[0], central[1])
	rotation_mtx = np.array([[1,0,central[0]],[0,1,central[1]],[0,0,1]]) @ np.array([[np.cos(theta),-np.sin(theta),0],[np.sin(theta),np.cos(theta),0],[0,0,1]]) @ np.array([[1,0,-central[0]],[0,1,-central[1]],[0,0,1]])
	inv_rotation_mtx = np.linalg.inv(rotation_mtx)
	print("rotation_mtx: \n",rotation_mtx)
#	print("inv_rotation_mtx: \n",inv_rotation_mtx)
	
	return inv_rotation_mtx
	


def caculate_scaling_mtx(img, height,width,hull_height,hull_width,central):
	central = Image_to_cartesian(img, central[0], central[1])	
	
	S_x = abs(hull_width / width)
	S_y = abs(hull_height / height)

#	print("S_x:",S_x)
#	print("S_y:",S_y)
	
	scaling_mtx = np.array([[1,0,central[0]],[0,1,central[1]],[0,0,1]]) @ np.array([[S_x,0,0],[0,S_y,0],[0,0,1]]) @ np.array([[1,0,-central[0]],[0,1,-central[1]],[0,0,1]])
	print("scaling_mtx:\n", scaling_mtx)
	inv_scaling_mtx = np.linalg.inv(scaling_mtx)

	return S_x, S_y, inv_scaling_mtx
	
def caculate_translation_mtx(img_seg, img, central, hull_center):
	central = Image_to_cartesian(img_seg, central[0], central[1])
	hull_center = Image_to_cartesian(img, hull_center[0], hull_center[1])

	T_x = hull_center[0] - central[0]
	T_y = hull_center[1] - central[1]
	
	translation_mtx = np.array([[1,0,central[0]],[0,1,central[1]],[0,0,1]]) @ np.array([[1,0, T_x],[0,1,T_y],[0,0,1]]) @ np.array([[1,0,-central[0]],[0,1,-central[1]],[0,0,1]])

	inv_translation_mtx = np.linalg.inv(translation_mtx)
	
	print(translation_mtx)
	
	
	return inv_translation_mtx
	
	
def geometric_manipulation(output_cartesian, inv_rotation_mtx):
	input_cartesian = inv_rotation_mtx @ output_cartesian
	
	return input_cartesian
	
def bilinear_interpolation(input_img,idx):
#	print(idx)
	if idx[0] == input_img.shape[0] - 1:
		if idx[1] == input_img.shape[1] - 1:	
			return input_img[int(idx[0])][int(idx[1])]
			
		else:
			w1 = 1 - (idx[1] - int(idx[1]))
			w2 = 1 - (int(idx[1]) + 1 - idx[1])
			return w1 * input_img[int(idx[0])][int(idx[1])] + w2 * input_img[int(idx[0])][int(idx[1]) + 1]
					
	elif idx[1] == (input_img.shape[1] - 1):
		
		w3 = 1 - (idx[0] - int(idx[0]))
		w4 = 1 - (int(idx[0]) + 1 - idx[0])
		
		return w3 * input_img[int(idx[0])][int(idx[1])] + w4 * input_img[int(idx[0]) + 1][int(idx[1])]
		
	else:
		w1 = 1 - (idx[1] - int(idx[1]))
		w2 = 1 - (int(idx[1]) + 1 - idx[1])
		w3 = 1 - (idx[0] - int(idx[0]))
		w4 = 1 - (int(idx[0]) + 1 - idx[0])
		p1 = input_img[int(idx[0])][int(idx[1])]
		p2 = input_img[int(idx[0])][int(idx[1]) + 1]
		p3 = input_img[int(idx[0]) + 1][int(idx[1])]
		p4 = input_img[int(idx[0]) + 1][int(idx[1]) + 1]
		
		
		return w3 * (w1 * p1 + w2 * p2) + w4 * (w1 * p3 + w2 * p4)
		
		
			
	
def main():


	[right_up, left_up, right_down, left_down] = findhull(img)
	
	
	print("right_up:", right_up)
	print("left_up: ", left_up)
	print("right_down: ", right_down)
	print("left_down: ", left_down)
	
	#calculate para of img1
	[right_1,left_1,up_1,down_1] = Findvertices(img1)
	[width_1, height_1, central_1, theta_1] = caculate_paras(right_1,left_1,up_1,down_1)
	
	hull_width_2 = right_up[1] - left_up[1] + 1
	hull_height_2 = right_down[0] - right_up[0] + 1
	hull_center_2 = np.array([(right_down[0] + right_up[0])/2, (right_up[1] + left_up[1])/2])
	 
	
	
	
	hull_width_1 = right_up[3] - left_up[3] + 1
	hull_height_1 = right_down[2] - right_up[2] + 1
	hull_center_1 = np.array([(right_down[2] + 1 + right_up[2])/2, (right_up[3] + 1 + left_up[3])/2]) 
	
	mark_1 = np.mean(img[left_up[2],left_up[3]:right_up[3]])

	
	hull_width_3 = right_up[5] - left_up[5] + 1
	hull_height_3 = right_down[4] - right_up[4] + 1
	hull_center_3 = np.array([(right_down[4] + 1 + right_up[4])/2, (right_up[5] + 1 + left_up[5])/2]) 

	
	
	
	print("hull_width:",hull_width_1)
	print("hull_height:",hull_height_1)
	print("hull_center:",hull_center_1)
	
	print("lighthouse1:")
	print("right:",right_1)
	print("left:",left_1)
	print("up:",up_1)
	print("down:",down_1)
	
	print("width_1:", width_1)
	print("height_1:",height_1)
	print("central_1:",central_1)
	print("theta_1:",theta_1)
	print("\n")

	
	#rotate img1
	
	
	inv_rotation_mtx_1 = caculate_rotation_mtx(img1,theta_1 - math.pi / 2 ,central_1)
	[S_x_1, S_y_1, inv_scaling_mtx_1] =  caculate_scaling_mtx(img1,height_1,width_1,hull_height_1,hull_width_1,central_1)
	inv_translation_mtx_1 = caculate_translation_mtx(img1, img, central_1, hull_center_1)
	transform_mtx_1 = inv_rotation_mtx_1 @ inv_scaling_mtx_1 @ inv_translation_mtx_1

	
	img1_t = np.full((img.shape[0],img.shape[1]),255) 

	
	for i in range(img1_t.shape[0]):
		for j in range(img1_t.shape[1]):
			output_cartesian = Image_to_cartesian(img1_t,i,j)
			input_cartesian = geometric_manipulation(output_cartesian, transform_mtx_1)
			idx = cartesian_to_Image(img1,input_cartesian)
			img1_t[i][j] = bilinear_interpolation(img1,idx)
			
	
#	#compute mark and fill the hole
#	puzzle_mark = np.mean(img1_t[left_up[2],left_up[3]:right_up[3]])
#	while puzzle_mark != mark_1:
#		theta_1 = theta_1 - math.pi / 2
#		inv_rotation_mtx_1 = caculate_rotation_mtx(img1,theta_1 ,hull_center_1)
#		
#		for i in range(img1_t.shape[0]):
#			for j in range(img1_t.shape[1]):
#				output_cartesian = Image_to_cartesian(img1_t,i,j)
#				input_cartesian = geometric_manipulation(output_cartesian, inv_rotation_mtx_1)
#				idx = cartesian_to_Image(img1,input_cartesian)
#				img1_t[i][j] = bilinear_interpolation(img1,idx)
	
	
	


		
	cv2.imwrite("img1_t.png",img1_t)
	
		
#	calculate para of img2
	[right_2,left_2,up_2,down_2] = Findvertices(img2)
	[width_2, height_2, central_2, theta_2] = caculate_paras(right_2,left_2,up_2,down_2)	
	
	print("lighthouse2:")
	print("right:",right_2)
	print("left:",left_2)
	print("up:",up_2)
	print("down:",down_2)
	
	print("width_2:", width_2)
	print("height_2:",height_2)
	print("central_2:",central_2)
	print("theta_2:",theta_2)
	print("\n")
	
#	rotate img2
	inv_rotation_mtx_2 = caculate_rotation_mtx(img2, theta_2 + math.pi ,central_2)
	[S_x_2, S_y_2, inv_scaling_mtx_2] =  caculate_scaling_mtx(img2,height_2,width_2,hull_height_2,hull_width_2,central_2)
	inv_translation_mtx_2 = caculate_translation_mtx(img2, img, central_2, hull_center_2)
	transform_mtx_2 = inv_rotation_mtx_2 @ inv_scaling_mtx_2 @ inv_translation_mtx_2
	
	img2_t = np.full((img.shape[0],img.shape[1]),255) 
	
	
	for i in range(img2_t.shape[0]):
		for j in range(img2_t.shape[1]):
			output_cartesian = Image_to_cartesian(img2_t,i,j)
			input_cartesian = geometric_manipulation(output_cartesian, transform_mtx_2)
			idx = cartesian_to_Image(img2,input_cartesian)
			img2_t[i][j] = bilinear_interpolation(img2,idx)
			
	cv2.imwrite("img2_rotated.png",img2_t)
		
#	calculate para of img3
	[right_3,left_3,up_3,down_3] = Findvertices(img3)
	[width_3, height_3, central_3, theta_3] = caculate_paras(right_3,left_3,up_3,down_3)	
	
	print("lighthouse3:")
	print("right:",right_3)
	print("left:",left_3)
	print("up:",up_3)
	print("down:",down_3)
	
	print("width_3:", width_3)
	print("height_3:",height_3)
	print("central_3:",central_3)
	print("theta_3:",theta_3)
	print("\n")
	
#	rotate img3
	inv_rotation_mtx_3 = caculate_rotation_mtx(img3, theta_3 ,central_3)
	[S_x_3, S_y_3, inv_scaling_mtx_3] =  caculate_scaling_mtx(img3,height_3,width_3,hull_height_3,hull_width_3,central_3)
	inv_translation_mtx_3 = caculate_translation_mtx(img3, img, central_3, hull_center_3)
	transform_mtx_3 = inv_rotation_mtx_3 @ inv_scaling_mtx_3 @ inv_translation_mtx_3
	
	img3_t = np.full((img.shape[0],img.shape[1]),255) 
	
	
	for i in range(img3_t.shape[0]):
		for j in range(img3_t.shape[1]):
			output_cartesian = Image_to_cartesian(img3_t,i,j)
			input_cartesian = geometric_manipulation(output_cartesian, transform_mtx_3)
			idx = cartesian_to_Image(img3,input_cartesian)
			img3_t[i][j] = bilinear_interpolation(img3,idx)
			
	cv2.imwrite("img3_rotated.png",img3_t)
	
	
	
	
	for i in range(157,316):
		for j in range(62,221):
			img_output[i][j] = img1_t[i][j]
			
	for i in range(31,190):
		for j in range(278,437):
			img_output[i][j] = img2_t[i][j]
			
	for i in range(328,487):
		for j in range(326,485):
			img_output[i][j] = img3_t[i][j]
			

			
	
	cv2.imwrite("lighthouse_filled.png",img_output)
#	imageio.imsave('lighthouse_filled.raw', img_output)
		
if __name__ == "__main__":
	
	img = np.fromfile('lighthouse.raw', dtype=np.uint8)
	img.shape = (512,512)
	
	img_output = np.fromfile('lighthouse.raw', dtype=np.uint8)
	img_output.shape = (512,512)
	#plt.imshow(img, cmap=plt.cm.gray)
	img1 = np.fromfile('lighthouse1.raw', dtype=np.uint8)
	img1.shape = (256,256)
	#plt.imshow(img, cmap=plt.cm.gray)
	img2 = np.fromfile('lighthouse2.raw', dtype=np.uint8)
	img2.shape = (256,256)
	#plt.imshow(img, cmap=plt.cm.gray)
	img3 = np.fromfile('lighthouse3.raw', dtype=np.uint8)
	img3.shape = (256,256)
	#plt.imshow(img, cmap=plt.cm.gray)

	main()#//(1) Name: Yifei Liu
	#//(2) USC ID Number: 3852294243 
	#//(3) USC Email: liu534@usc.edu
	#//(4) Submission Date: 3/3/2019


	import cv2
	from matplotlib import pyplot as plt
	import numpy as np
	import math

			
		
	def Image_to_cartesian(img,i,j):
		index = np.array([[i+1],[j+1],[1]])
		cartesian = np.zeros((3,1))
		mtx = np.array([[0,1,-0.5],[-1,0,img.shape[0]+0.5],[0,0,1]])
		cartesian = mtx @ index
		
	#	print(cartesian)
		return cartesian

	def cartesian_to_Image(img,cartesian):
		cartesian = np.array([[cartesian[0]],[cartesian[1]],[1]])
		idx = np.zeros((3,1))
		mtx = np.array([[0,-1,img.shape[0]+0.5],[1,0,0.5],[0,0,1]])
		idx = mtx @ cartesian - [[1],[1],[0]]
	#	print(idx)
		
	#	if idx[0] > img.shape[0] - 1:
	#		idx[0] = img.shape[0] - 1
	#	elif idx[0] < 0:
	#		idx[0] = 0
	#		
	#	if idx[1] > img.shape[1] - 1:
	#		idx[1] = img.shape[1] - 1
	#	elif idx[1] < 0:
	#		idx[1] = 0
			
	#	print("idx:\n",idx)
		return idx




		
	def geometric_manipulation(output_cartesian, inv_rotation_mtx):
		
		output_cartesian
		
		output_vector = np.zeros((6,))

		x = output_cartesian[0]
		y = output_cartesian[1]
		output_vector = [1,x,y,x**2,x*y,y**2]
		input_cartesian = inv_rotation_mtx @ output_vector
		
		return input_cartesian
		
	def bilinear_interpolation(input_img,idx):
	#	print(idx)
		if idx[0] == input_img.shape[0] - 1:
			if idx[1] == input_img.shape[1] - 1:	
				return input_img[int(idx[0])][int(idx[1])]
				
			else:
				w1 = 1 - (idx[1] - int(idx[1]))
				w2 = 1 - (int(idx[1]) + 1 - idx[1])
				return w1 * input_img[int(idx[0])][int(idx[1])] + w2 * input_img[int(idx[0])][int(idx[1]) + 1]
						
		elif idx[1] == (input_img.shape[1] - 1):
			
			w3 = 1 - (idx[0] - int(idx[0]))
			w4 = 1 - (int(idx[0]) + 1 - idx[0])
			
			return w3 * input_img[int(idx[0])][int(idx[1])] + w4 * input_img[int(idx[0]) + 1][int(idx[1])]
			
		else:
			w1 = 1 - (idx[1] - int(idx[1]))
			w2 = 1 - (int(idx[1]) + 1 - idx[1])
			w3 = 1 - (idx[0] - int(idx[0]))
			w4 = 1 - (int(idx[0]) + 1 - idx[0])
			p1 = input_img[int(idx[0])][int(idx[1])]
			p2 = input_img[int(idx[0])][int(idx[1]) + 1]
			p3 = input_img[int(idx[0]) + 1][int(idx[1])]
			p4 = input_img[int(idx[0]) + 1][int(idx[1]) + 1]
			
			
			return w3 * (w1 * p1 + w2 * p2) + w4 * (w1 * p3 + w2 * p4)
			
			
	def comput_paras(input_point, output_point):

		input_point_cart = np.zeros((3,len(input_point))) #3*6
		output_point_cart = np.zeros((3,len(output_point))) #3*6
		
		output_mtx = np.zeros((6,len(output_point)))
		print("# of control point:",len(input_point))
		
		for i in range(len(input_point)):
			input_point_cart[:,i] = list(Image_to_cartesian(img,input_point[i][0],input_point[i][1]))
			output_point_cart[:,i] = list(Image_to_cartesian(img,output_point[i][0],output_point[i][1]))
			x = output_point_cart[0,i]
			y = output_point_cart[1,i]
			output_mtx[:,i] = list([1,x,y,x**2,x*y,y**2])
		


			
	#	print(np.linalg.pinv(output_mtx))
		inv_warp_mtx = input_point_cart[0:2,:] @ np.linalg.pinv(output_mtx)
			
		print(inv_warp_mtx)
		
		return inv_warp_mtx
			
		
	def main():
		input_point_up = np.array([[0,256],[0,512],[0,0],[256,256],[128,128],[128,384]])
		output_point_up = np.array([[128, 256], [0, 512],[0,0],[256,256],[128,128],[128,384]])
		
		input_point_down = np.array([[512,0],[512,512],[512,256],[384,128],[384,384],[256,256]])
		output_point_down = np.array([[512,0], [512, 512],[384,256],[384,128],[384,384],[256,256]])
		
		input_point_left = np.array([[256,0],[512,0],[0,0],[256,256],[128,128],[384,128]])
		output_point_left = np.array([[256,128], [512,0],[0,0],[256,256],[128,128],[384,128]])
		
		input_point_right = np.array([[256, 512],[0,512],[512,512],[256,256],[128,384],[384,384]])
		output_point_right = np.array([[256, 384], [0, 512],[512,512],[256,256],[128,384],[384,384]])

		inv_warp_mtx_up = comput_paras(input_point_up,output_point_up)
		inv_warp_mtx_down = comput_paras(input_point_down,output_point_down)
		inv_warp_mtx_left = comput_paras(input_point_left,output_point_left)
		inv_warp_mtx_right = comput_paras(input_point_right,output_point_right)
			
		
		
	#	for i in range(512):
	#		for j in range(0,min(i,512 - i)):
	#			img_left[i,j] = img[i,j]
	#		
	#
	#	cv2.imwrite("hat_left.png",img_left)

		
		img_w = np.full((img.shape[0],img.shape[1]),0) 
		
		for i in range(256):
			for j in range(i,512 - i):
				output_cartesian = Image_to_cartesian(img_w,i,j)
	#			print(output_cartesian)
				input_cartesian = geometric_manipulation(output_cartesian[0:2], inv_warp_mtx_up) #[u,v]
	#			print(input_cartesian)
				idx = cartesian_to_Image(img,input_cartesian) #
	#			print(idx)
	#			img_w[i][j] = img[int(idx[0]),int(idx[1])]
				if idx[0] >= 0 and idx[1] >= 0:
					img_w[i][j] = bilinear_interpolation(img,idx)
				else:
					img_w[i][j] = 0
	#			print(img_w[i][j])

		for i in range(512):
			for j in range(0,min(i,512 - i)):
				output_cartesian = Image_to_cartesian(img_w,i,j)
	#			print(output_cartesian)
				input_cartesian = geometric_manipulation(output_cartesian[0:2], inv_warp_mtx_left) #[u,v]
	#			print(input_cartesian)
				idx = cartesian_to_Image(img,input_cartesian) #
	#			print(idx)
	#			img_w[i][j] = img[int(idx[0]),int(idx[1])]
				if idx[0] >= 0 and idx[1] >= 0:
					img_w[i][j] = bilinear_interpolation(img,idx)
				else:
					img_w[i][j] = 0
	#			print(img_w[i][j])

		for i in range(512):
			for j in range(max(i,512 - i),512):
				output_cartesian = Image_to_cartesian(img_w,i,j)
	#			print(output_cartesian)
				input_cartesian = geometric_manipulation(output_cartesian[0:2], inv_warp_mtx_right) #[u,v]
	#			print(input_cartesian)
				idx = cartesian_to_Image(img,input_cartesian) #
	#			print(idx)
	#			img_w[i][j] = img[int(idx[0]),int(idx[1])]
				if idx[0] >= 0 and idx[1] >= 0 and idx[0] < 511 and idx[1] < 511:
					img_w[i][j] = bilinear_interpolation(img,idx)
				else:
					img_w[i][j] = 0
	#			print(img_w[i][j])

		for i in range(256, 512):
			for j in range(512 - i,i):
				output_cartesian = Image_to_cartesian(img_w,i,j)
	#			print(output_cartesian)
				input_cartesian = geometric_manipulation(output_cartesian[0:2], inv_warp_mtx_down) #[u,v]
	#			print(input_cartesian)
				idx = cartesian_to_Image(img,input_cartesian) #
	#			print(idx)
	#			img_w[i][j] = img[int(idx[0]),int(idx[1])]
				if idx[0] >= 0 and idx[1] >= 0 and idx[0] < 511 and idx[1] < 511:
					img_w[i][j] = bilinear_interpolation(img,idx)
				else:
					img_w[i][j] = 0
	#			print(img_w[i][j])


				
		cv2.imwrite("hat_w_left.png",img_w)

		
			
			
	if __name__ == "__main__":
		
		img = np.fromfile('hat.raw', dtype=np.uint8)
		img.shape = (512,512)
		

		main()clear all
		K1 = -0.3536;
		K2 =  0.1730;
		u_c = (712/2) ;
		v_c = (1072/2);

		distoredImg = imread('classroom.png');
		new_img = zeros(712,1072);
		p = 1.5;

		x_cut = 356;
		y_cut = 536;


		% Mtx_Xd = zeros(3,100)

		% Mtx_Xd = zeros(N,3);
		% Mtx_Yd = zeros(N,3);

		%% left-up:
		% Mtx_Xd_left_up = zeros(356*536,3);
		% Mtx_Yd_left_up = zeros(356*536,3);
		i = 1;
		for x = 1:x_cut
			for y = 1:y_cut
				
				x_c = (x - u_c)/600;
				y_c = (y - v_c)/600;

				Xd = x_c * (1 + K1 * (x_c^2 + y_c^2) + K2 * (x_c^2 + y_c^2)^2);
				Yd = y_c * (1 + K1 * (x_c^2 + y_c^2) + K2 * (x_c^2 + y_c^2)^2);
			
			
				Mtx_Xd_left_up(i,:) = [x_c, y_c, Xd];
				Mtx_Yd_left_up(i,:) = [x_c, y_c, Yd];
				
				i = i + 1;
			end


		end

		[Yb_left_up,BINT,Rb_Y_left_up] = regress(Mtx_Yd_left_up(:,3),Mtx_Yd_left_up(:,1:2));
		[Xb_left_up,BINT,Rb_X_left_up] = regress(Mtx_Xd_left_up(:,3),Mtx_Xd_left_up(:,1:2));


		% 
		% for x = 1:356
		%     for y = 1:536
		%         x_c = (x - u_c)/600;
		% 		y_c = (y - v_c)/600;
		% 
		%         Xd_new = [x_c,y_c] * Xb_left_up + mean(Rb_X_left_up);
		%         Yd_new = [x_c,y_c] * Yb_left_up + mean(Rb_Y_left_up);
		%         
		%         Xd_new = p * Xd_new;
		%         Yd_new = p * Yd_new;
		%         
		%         u = 600 * Xd_new + u_c;
		% 		v = 600 * Yd_new + v_c;
		%         
		%         if int64(u) <= 712 && int64(u) >= 1 
		%             if int64(v) <= 1072 && int64(v) >= 1
		%                 new_img(x,y) = distoredImg(int64(u),int64(v));
		%             end
		%         end
		%     end
		% end
			
		%% left-down

		% Mtx_Xd_left_down = zeros(356*536,3);
		% Mtx_Yd_left_down = zeros(356*536,3);

		i = 1;
		for x = 712-x_cut+1:712
			for y = 1:y_cut
				
				x_c = (x - u_c)/600;
				y_c = (y - v_c)/600;

				Xd = x_c * (1 + K1 * (x_c^2 + y_c^2) + K2 * (x_c^2 + y_c^2)^2);
				Yd = y_c * (1 + K1 * (x_c^2 + y_c^2) + K2 * (x_c^2 + y_c^2)^2);
			
			
				Mtx_Xd_left_down(i,:) = [x_c, y_c, Xd];
				Mtx_Yd_left_down(i,:) = [x_c, y_c, Yd];
				
				
				i = i + 1;
			end


		end

		[Yb_left_down,BINT,Rb_Y_left_down] = regress(Mtx_Yd_left_down(:,3),Mtx_Yd_left_down(:,1:2));
		[Xb_left_down,BINT,Rb_X_left_down] = regress(Mtx_Xd_left_down(:,3),Mtx_Xd_left_down(:,1:2));



		% for x =  712-x_cut+1:712
		%     for y = 1:y_cut
		%         x_c = (x - u_c)/600;
		% 		y_c = (y - v_c)/600;
		% 
		%         Xd_new = [x_c,y_c] * Xb_left_down + mean(Rb_X_left_down);
		%         Yd_new = [x_c,y_c] * Yb_left_down + mean(Rb_Y_left_down);
		%         
		%         Xd_new = p * Xd_new;
		%         Yd_new = p * Yd_new;
		%         
		%         u = 600 * Xd_new + u_c;
		% 		v = 600 * Yd_new + v_c;
		%         
		%         if int64(u) <= 712 && int64(u) >= 1 
		%             if int64(v) <= 1072 && int64(v) >= 1
		%                 new_img(x,y) = distoredImg(int64(u),int64(v));
		%             end
		%         end
		%     end
		% end


		%% right-up

		% Mtx_Xd_right_up = zeros(356*536,3);
		% Mtx_Yd_right_up = zeros(356*536,3);

		i = 1;
		for x = 1:x_cut
			for y = 1072-y_cut+1:1072
				
				x_c = (x - u_c)/600;
				y_c = (y - v_c)/600;

				Xd = x_c * (1 + K1 * (x_c^2 + y_c^2) + K2 * (x_c^2 + y_c^2)^2);
				Yd = y_c * (1 + K1 * (x_c^2 + y_c^2) + K2 * (x_c^2 + y_c^2)^2);
			
			
				Mtx_Xd_right_up(i,:) = [x_c, y_c, Xd];
				Mtx_Yd_right_up(i,:) = [x_c, y_c, Yd];
				
				
				i = i + 1;
			end


		end

		[Yb_right_up,BINT,Rb_Y_right_up] = regress(Mtx_Yd_right_up(:,3),Mtx_Yd_right_up(:,1:2));
		[Xb_right_up,BINT,Rb_X_right_up] = regress(Mtx_Xd_right_up(:,3),Mtx_Xd_right_up(:,1:2));

		% 
		% 
		% for x = 1:x_cut
		%     for y = 1072-y_cut+1:1072
		%         x_c = (x - u_c)/600;
		% 		y_c = (y - v_c)/600;
		% 
		%         Xd_new = [x_c,y_c] * Xb_right_up + mean(Rb_X_right_up);
		%         Yd_new = [x_c,y_c] * Yb_right_up + mean(Rb_Y_right_up);
		%         
		%         Xd_new = p * Xd_new;
		%         Yd_new = p * Yd_new;
		%         
		%         u = 600 * Xd_new + u_c;
		% 		  v = 600 * Yd_new + v_c;
		%         
		%         if int64(u) <= 712 && int64(u) >= 1 
		%             if int64(v) <= 1072 && int64(v) >= 1
		%                 new_img(x,y) = distoredImg(int64(u),int64(v));
		%             end
		%         end
		%     end
		% end

		%% right-down

		% Mtx_Xd_right_down = zeros(356*536,3);
		% Mtx_Yd_right_down = zeros(356*536,3);
		i = 1;
		for x = 712-x_cut+1:712
			for y = 1072-y_cut+1:1072
				
				x_c = (x - u_c)/600;
				y_c = (y - v_c)/600;

				Xd = x_c * (1 + K1 * (x_c^2 + y_c^2) + K2 * (x_c^2 + y_c^2)^2);
				Yd = y_c * (1 + K1 * (x_c^2 + y_c^2) + K2 * (x_c^2 + y_c^2)^2);
			
			
				Mtx_Xd_right_down(i,:) = [x_c, y_c, Xd];
				Mtx_Yd_right_down(i,:) = [x_c, y_c, Yd];
				
		 
				
				i = i + 1;
			end


		end

		[Yb_right_down,BINT,Rb_Y_right_down] = regress(Mtx_Yd_right_down(:,3),Mtx_Yd_right_down(:,1:2));
		[Xb_right_down,BINT,Rb_X_right_down] = regress(Mtx_Xd_right_down(:,3),Mtx_Xd_right_down(:,1:2));



		for x = 1:712
			for y = 1:1072
				x_c = (x - u_c)/600;
				y_c = (y - v_c)/600;

				Xd_new = [x_c,y_c] * Xb_right_down + mean(Rb_X_right_down);
				Yd_new = [x_c,y_c] * Yb_right_down + mean(Rb_Y_right_down);
				
				Xd_new = [x_c,y_c] * Xb_left_up + mean(Rb_X_left_up);
				Yd_new = [x_c,y_c] * Yb_left_up + mean(Rb_Y_left_up);   
				
				Xd_new = [x_c,y_c] * Xb_right_up + mean(Rb_X_right_up);
				Yd_new = [x_c,y_c] * Yb_right_up + mean(Rb_Y_right_up);
				
				Xd_new = [x_c,y_c] * Xb_left_down + mean(Rb_X_left_down);
				Yd_new = [x_c,y_c] * Yb_left_down + mean(Rb_Y_left_down);   
				
				
				Xd_new = p * Xd_new;
				Yd_new = p * Yd_new;
				
				u = 600 * Xd_new + u_c;
				v = 600 * Yd_new + v_c;
				
				if int64(u) <= 712 && int64(u) >= 1 
					if int64(v) <= 1072 && int64(v) >= 1
						new_img(x,y) = distoredImg(int64(u),int64(v));
					end
				end
			end
		end

				


		imwrite(uint8(new_img),"recovered_class_two_corner.png")

		%% fuction mapping

		new_img_funtion = zeros(712,1072);
		for i = 1:712
			for j = 1:1072
		%      img to camera

				x = (i-u_c)/600;
				y = (j-v_c)/600;
				
				
				Xd_new = x * (1 + K1 * (x^2 + y^2) + K2 * (x^2 + y^2)^2);
				Yd_new = y * (1 + K1 * (x^2 + y^2) + K2 * (x^2 + y^2)^2);
				
				Xd_new = p * Xd_new;
				Yd_new = p * Yd_new;
		%       camera to img
				

				u = 600 * Xd_new + u_c;
				v = 600 * Yd_new + v_c;
				
				if int64(u) <= 712 && int64(u) >= 1
					if int64(v) <= 1072 && int64(v) >= 1
						new_img_funtion(i,j) = distoredImg(int64(u),int64(v));
					else
					new_img_funtion(i,j) = 0;
					end
				end
			end
		end

		imwrite(uint8(new_img_funtion),"recovered_class_fuction.png")

			//(1) Name: Yifei Liu
			//(2) USC ID Number: 3852294243 
			//(3) USC Email: liu534@usc.edu
			//(4) Submission Date: 3/3/2019

			#include <stdio.h>
			#include <iostream>
			#include <stdlib.h>
			#include <cmath>

			using namespace std;

			int convert(float num){

				if(num > 255){
					num = 255;
				}

				if(num < 0){
					num = 0;
				}
				return num;
			}


			int main(int argc, char *argv[])

			{
				// Define file pointer and variables
				FILE *file;
				int BytesPerPixel;
				//int Size = 256;
				int Row;
				int Column;

				
				// Check for proper syntax
				if (argc < 4){
					cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
					cout << "program_name input_image.raw ori_image.raw output_image.raw [BytesPerPixel = 1] [Row = 256] [Column = 256]" << endl;
					//cout << "program_name 1.input_image.raw 2.ori_image.raw 3.output_image.raw 4.[BytesPerPixel = 1] 5.[Row = 256] 6.[Column = 256]" << endl;

					return 0;
				}
				
				// Check if image is grayscale or color
				if (argc < 3){
					BytesPerPixel = 1; // default is grey image
				} 
				else {
					BytesPerPixel = atoi(argv[3]);
					// Check if size is specified
					if (argc >= 3){
			//			Size = atoi(argv[4]);
						//BytesPerPixel = atoi(argv[3]);
						Row = atoi(argv[4]);
						Column = atoi(argv[5]);
					}
				}
				cout << "Row and Column: " << Row << " and " << Column <<endl;
				cout << "Bytebypixels: " << BytesPerPixel <<endl;
				
				// Allocate image data array
				unsigned char Imagedata[Row][Column][BytesPerPixel];



				// Read image (filename specified by first argument) into image data matrix
				if (!(file=fopen(argv[1],"rb"))) {
					cout << "Cannot open file: " << argv[1] <<endl;
					exit(1);
				}
				fread(Imagedata, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
				fclose(file);
				cout << "Target Image read succeed!" <<endl;


				
				///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////
				long int conditional_mask[58] = {1000000,10000,100,1,10000000,100000,1000,10,11000000,1100000,110000,11000,1100,110,11,10000001,11000001,1110000,11100,111,10110000,10100001,1101000,11000010,11100000,111000,1110,10000011,10110001,1101100,11110000,11100001,1111000,111100,11110,1111,10000111,11000011,11110001,1111100,11111,11000111,11100011,11111000,111110,10001111,11110011,11100111,11111100,11111001,1111110,111111,10011111,11001111,11110111,11111101,1111111,11011111};


					
				long int unconditional_mask[364] = {1000000,10000,10,10000000,11000000,1100000,110000,11000,1100,110,11,10000001,1101000,10110000,10100001,11000010,11000100,1100100,11100100,110001,11001,111001,1000110,1001100,1001110,10010001,10011,10010011,111000,111001,10111000,10111001,1111000,1111001,11111000,11111001,111010,111011,10111010,10111011,1111010,1111011,11111010,11111011,111100,111101,10111100,10111101,1111100,1111101,11111100,11111101,111110,111111,10111110,10111111,1111110,1111111,11111110,11111111,101010,1101010,111010,1111010,101010,101011,101110,101111,10100010,10100011,10100110,10100111,10100010,11100010,10110010,11110010,10101000,10101100,10111000,10111100,10101000,10101001,11101000,11101001,10001010,10001011,11001010,11001011,10001010,10001110,10011010,10011110,10101,10010100,10010101,1010100,1010101,11010100,11010101,10111,10010110,10010111,1010110,1010111,11010110,11010111,110101,10110100,10110101,1110100,1110101,11110100,11110101,110111,10110110,10110111,1110110,1110111,11110110,11110111,11101,10011100,10011101,1011100,1011101,11011100,11011101,11111,10011110,10011111,1011110,1011111,11011110,11011111,111101,10111100,10111101,1111100,1111101,11111100,11111101,111111,10111110,10111111,1111110,1111111,11111110,11111111,1010100,1010010,1010110,1010001,1010101,1010011,1010111,11010100,11010010,11010110,11010001,11010101,11010011,11010111,1110100,1110010,1110110,1110001,1110101,1110011,1110111,11110100,11110010,11110110,11110001,11110101,11110011,11110111,1011100,1011010,1011110,1011001,1011101,1011011,1011111,11011100,11011010,11011110,11011001,11011101,11011011,11011111,1111100,1111010,1111110,1111001,1111101,1111011,1111111,11111100,11111010,11111110,11111001,11111101,11111011,11111111,1000101,1001001,1001101,1010001,1010101,1011001,1011101,11000101,11001001,11001101,11010001,11010101,11011001,11011101,1000111,1001011,1001111,1010011,1010111,1011011,1011111,11000111,11001011,11001111,11010011,11010111,11011011,11011111,1100101,1101001,1101101,1110001,1110101,1111001,1111101,11100101,11101001,11101101,11110001,11110101,11111001,11111101,1100111,1101011,1101111,1110011,1110111,1111011,1111111,11100111,11101011,11101111,11110011,11110111,11111011,11111111,1000101,100101,1100101,10101,1010101,110101,1110101,11000101,10100101,11100101,10010101,11010101,10110101,11110101,1000111,100111,1100111,10111,1010111,110111,1110111,11000111,10100111,11100111,10010111,11010111,10110111,11110111,1001101,101101,1101101,11101,1011101,111101,1111101,11001101,10101101,11101101,10011101,11011101,10111101,11111101,1001111,101111,1101111,11111,1011111,111111,1111111,11001111,10101111,11101111,10011111,11011111,10111111,11111111,1001010,1001011,1011010,1011011,101001,1101001,101101,1101101,10100100,10100101,10110100,10110101,10010010,11010010,10010110,11010110,111000,111001,10111000,10111001,1111000,1111001,11111000,11111001,111010,111011,10111010,10111011,1111010,1111011,11111010,11111011,111100,111101,10111100,10111101,1111100,1111101,11111100,11111101,111110,111111,10111110,10111111,1111110,1111111,11111110,11111111};
					
				
				
				
				int Imagedata_N[Row][Column][1] ;
				int Imagedata_M[Row][Column][1] ;
				unsigned char Imagedata_output[Row][Column][1];
				
				for(int i = 0; i < Row; i++){
					for(int j = 0; j < Column; j++){
						Imagedata_N[i][j][0] = (int)Imagedata[i][j][0] / 255;

					}
				}
				
				int _flag = 1;
				int iter = 0;
				
				while(_flag==1){
					_flag = 0;
					iter = iter + 1;
			//		cout<<"iter times: "<< iter << endl;
					for(int i = 1; i < Row - 1; i++){
						for(int j = 1; j < Column - 1; j++){
							Imagedata_M[i][j][0] = 0;
							long int compare = 10000000*Imagedata_N[i][j+1][0] + 1000000*Imagedata_N[i-1][j+1][0] + 100000*Imagedata_N[i-1][j][0] + 10000*Imagedata_N[i-1][j-1][0] + 1000*Imagedata_N[i][j-1][0] + 100*Imagedata_N[i+1][j-1][0] + 10*Imagedata_N[i+1][j][0] + Imagedata_N[i+1][j+1][0];
							for(int k = 0; k < 58; k++){
								Imagedata_M[i][j][0] = Imagedata_N[i][j][0] && !(compare^conditional_mask[k]);
								if(Imagedata_M[i][j][0]){
									break;
								}
							}
						}
					}
				
					int k;
					for(int i = 1; i < Row - 1; i++){
						for(int j = 1; j < Column - 1; j++){
							int compare = 10000000*Imagedata_M[i][j+1][0] + 1000000*Imagedata_M[i-1][j+1][0] + 100000*Imagedata_M[i-1][j][0] + 10000*Imagedata_M[i-1][j-1][0] + 1000*Imagedata_M[i][j-1][0] + 100*Imagedata_M[i+1][j-1][0] + 10*Imagedata_M[i+1][j][0] + Imagedata_M[i+1][j+1][0];
							for(k = 0; k < 364; k++){
								if(!(compare^unconditional_mask[k])){
									break;
								}
							}
							if(k == 364){
								int temp = Imagedata_N[i][j][0];
								Imagedata_N[i][j][0] = Imagedata_N[i][j][0] && (!Imagedata_M[i][j][0]);
								if (temp != Imagedata_N[i][j][0]){
									_flag = 1;
								}
								
							}
						}
					}
				}
				cout<<"iter times: "<< iter << endl;
				

				
				
				for(int i = 0; i < Row; i++){
					for(int j = 0; j < Column; j++){
						Imagedata_output[i][j][0] = 255 * Imagedata_N[i][j][0];
					}
				}
				
				
				
				////////////////////////// END CODE ////////////////////////////////////////////////


				// Write image data (filename specified by second argument) from image data matrix

				if (!(file=fopen(argv[2],"wb"))) {
					cout << "Cannot open file: " << argv[5] << endl;
					exit(1);
				}
				fwrite(Imagedata_output, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
				fclose(file);

				return 0;
			}
			//(1) Name: Yifei Liu
			//(2) USC ID Number: 3852294243 
			//(3) USC Email: liu534@usc.edu
			//(4) Submission Date: 1/22/2019

			#include <stdio.h>
			#include <iostream>
			#include <stdlib.h>
			#include <cmath>

			using namespace std;

			int convert(float num){

				if(num > 255){
					num = 255;
				}

				if(num < 0){
					num = 0;
				}
				return num;
			}


			int main(int argc, char *argv[])

			{
				// Define file pointer and variables
				FILE *file;
				int BytesPerPixel;
				//int Size = 256;
				int Row;
				int Column;

				
				// Check for proper syntax
				if (argc < 4){
					cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
					cout << "program_name input_image.raw ori_image.raw output_image.raw [BytesPerPixel = 1] [Row = 256] [Column = 256]" << endl;
					//cout << "program_name 1.input_image.raw 2.ori_image.raw 3.output_image.raw 4.[BytesPerPixel = 1] 5.[Row = 256] 6.[Column = 256]" << endl;

					return 0;
				}
				
				// Check if image is grayscale or color
				if (argc < 3){
					BytesPerPixel = 1; // default is grey image
				} 
				else {
					BytesPerPixel = atoi(argv[3]);
					// Check if size is specified
					if (argc >= 3){
			//			Size = atoi(argv[4]);
						//BytesPerPixel = atoi(argv[3]);
						Row = atoi(argv[4]);
						Column = atoi(argv[5]);
					}
				}
				cout << "Row and Column: " << Row << " and " << Column <<endl;
				cout << "Bytebypixels: " << BytesPerPixel <<endl;
				
				// Allocate image data array
				unsigned char Imagedata[Row][Column][BytesPerPixel];



				// Read image (filename specified by first argument) into image data matrix
				if (!(file=fopen(argv[1],"rb"))) {
					cout << "Cannot open file: " << argv[1] <<endl;
					exit(1);
				}
				fread(Imagedata, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
				fclose(file);
				cout << "Target Image read succeed!" <<endl;


				
				///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////
				long int conditional_mask[46] = {10100000,101000,1010,10000010,11000001,1110000,11100,111,10110000,10100001,1101000,11000010,11100000,111000,1110,10000011,10110001,1101100,11110000,11100001,1111000,111100,11110,1111,10000111,11000011,11110001,1111100,11111,11000111,11100011,11111000,111110,10001111,11110011,11100111,11111100,11111001,1111110,111111,10011111,11001111,11110111,11111101,1111111,11011111};


					
				long int unconditional_mask[364] = {1000000,10000,10,10000000,11000000,1100000,110000,11000,1100,110,11,10000001,1101000,10110000,10100001,11000010,11000100,1100100,11100100,110001,11001,111001,1000110,1001100,1001110,10010001,10011,10010011,111000,111001,10111000,10111001,1111000,1111001,11111000,11111001,111010,111011,10111010,10111011,1111010,1111011,11111010,11111011,111100,111101,10111100,10111101,1111100,1111101,11111100,11111101,111110,111111,10111110,10111111,1111110,1111111,11111110,11111111,101010,1101010,111010,1111010,101010,101011,101110,101111,10100010,10100011,10100110,10100111,10100010,11100010,10110010,11110010,10101000,10101100,10111000,10111100,10101000,10101001,11101000,11101001,10001010,10001011,11001010,11001011,10001010,10001110,10011010,10011110,10101,10010100,10010101,1010100,1010101,11010100,11010101,10111,10010110,10010111,1010110,1010111,11010110,11010111,110101,10110100,10110101,1110100,1110101,11110100,11110101,110111,10110110,10110111,1110110,1110111,11110110,11110111,11101,10011100,10011101,1011100,1011101,11011100,11011101,11111,10011110,10011111,1011110,1011111,11011110,11011111,111101,10111100,10111101,1111100,1111101,11111100,11111101,111111,10111110,10111111,1111110,1111111,11111110,11111111,1010100,1010010,1010110,1010001,1010101,1010011,1010111,11010100,11010010,11010110,11010001,11010101,11010011,11010111,1110100,1110010,1110110,1110001,1110101,1110011,1110111,11110100,11110010,11110110,11110001,11110101,11110011,11110111,1011100,1011010,1011110,1011001,1011101,1011011,1011111,11011100,11011010,11011110,11011001,11011101,11011011,11011111,1111100,1111010,1111110,1111001,1111101,1111011,1111111,11111100,11111010,11111110,11111001,11111101,11111011,11111111,1000101,1001001,1001101,1010001,1010101,1011001,1011101,11000101,11001001,11001101,11010001,11010101,11011001,11011101,1000111,1001011,1001111,1010011,1010111,1011011,1011111,11000111,11001011,11001111,11010011,11010111,11011011,11011111,1100101,1101001,1101101,1110001,1110101,1111001,1111101,11100101,11101001,11101101,11110001,11110101,11111001,11111101,1100111,1101011,1101111,1110011,1110111,1111011,1111111,11100111,11101011,11101111,11110011,11110111,11111011,11111111,1000101,100101,1100101,10101,1010101,110101,1110101,11000101,10100101,11100101,10010101,11010101,10110101,11110101,1000111,100111,1100111,10111,1010111,110111,1110111,11000111,10100111,11100111,10010111,11010111,10110111,11110111,1001101,101101,1101101,11101,1011101,111101,1111101,11001101,10101101,11101101,10011101,11011101,10111101,11111101,1001111,101111,1101111,11111,1011111,111111,1111111,11001111,10101111,11101111,10011111,11011111,10111111,11111111,1001010,1001011,1011010,1011011,101001,1101001,101101,1101101,10100100,10100101,10110100,10110101,10010010,11010010,10010110,11010110,111000,111001,10111000,10111001,1111000,1111001,11111000,11111001,111010,111011,10111010,10111011,1111010,1111011,11111010,11111011,111100,111101,10111100,10111101,1111100,1111101,11111100,11111101,111110,111111,10111110,10111111,1111110,1111111,11111110,11111111};
					
				
				
				
				int Imagedata_N[Row][Column][1] ;
				int Imagedata_M[Row][Column][1] ;
				unsigned char Imagedata_output[Row][Column][1];
				
				for(int i = 0; i < Row; i++){
					for(int j = 0; j < Column; j++){
						Imagedata_N[i][j][0] = (int)Imagedata[i][j][0] / 255;

					}
				}
				
				int _flag = 1;
				int iter = 1;
				
				while(_flag==1){
					_flag = 0;
					iter = iter + 1;
			//		cout<<"iter times: "<< iter << endl;
					for(int i = 1; i < Row - 1; i++){
						for(int j = 1; j < Column - 1; j++){
							Imagedata_M[i][j][0] = 0;
							long int compare = 10000000*Imagedata_N[i][j+1][0] + 1000000*Imagedata_N[i-1][j+1][0] + 100000*Imagedata_N[i-1][j][0] + 10000*Imagedata_N[i-1][j-1][0] + 1000*Imagedata_N[i][j-1][0] + 100*Imagedata_N[i+1][j-1][0] + 10*Imagedata_N[i+1][j][0] + Imagedata_N[i+1][j+1][0];
							for(int k = 0; k < 46; k++){
								Imagedata_M[i][j][0] = Imagedata_N[i][j][0] && !(compare^conditional_mask[k]);
								if(Imagedata_M[i][j][0]){
									break;
								}
							}
						}
					}
				
					int k;
					for(int i = 1; i < Row - 1; i++){
						for(int j = 1; j < Column - 1; j++){
							int compare = 10000000*Imagedata_M[i][j+1][0] + 1000000*Imagedata_M[i-1][j+1][0] + 100000*Imagedata_M[i-1][j][0] + 10000*Imagedata_M[i-1][j-1][0] + 1000*Imagedata_M[i][j-1][0] + 100*Imagedata_M[i+1][j-1][0] + 10*Imagedata_M[i+1][j][0] + Imagedata_M[i+1][j+1][0];
							for(k = 0; k < 364; k++){
								if(!(compare^unconditional_mask[k])){
									break;
								}
							}
							if(k == 364){
								int temp = Imagedata_N[i][j][0];
								Imagedata_N[i][j][0] = Imagedata_N[i][j][0] && (!Imagedata_M[i][j][0]);
								if (temp != Imagedata_N[i][j][0]){
									_flag = 1;
								}
								
							}
						}
					}
				}
				cout<<"iter times: "<< iter << endl;

				
				
				for(int i = 0; i < Row; i++){
					for(int j = 0; j < Column; j++){
						Imagedata_output[i][j][0] = 255 * Imagedata_N[i][j][0];
					}
				}
				
				
				
				////////////////////////// END CODE ////////////////////////////////////////////////


				// Write image data (filename specified by second argument) from image data matrix

				if (!(file=fopen(argv[2],"wb"))) {
					cout << "Cannot open file: " << argv[5] << endl;
					exit(1);
				}
				fwrite(Imagedata_output, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
				fclose(file);

				return 0;
			}
			//(1) Name: Yifei Liu
			//(2) USC ID Number: 3852294243 
			//(3) USC Email: liu534@usc.edu
			//(4) Submission Date: 1/22/2019

			#include <stdio.h>
			#include <iostream>
			#include <stdlib.h>
			#include <cmath>

			using namespace std;

			int convert(float num){

				if(num > 255){
					num = 255;
				}

				if(num < 0){
					num = 0;
				}
				return num;
			}


			int main(int argc, char *argv[])

			{
				// Define file pointer and variables
				FILE *file;
				int BytesPerPixel;
				//int Size = 256;
				int Row;
				int Column;

				
				// Check for proper syntax
				if (argc < 4){
					cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
					cout << "program_name input_image.raw ori_image.raw output_image.raw [BytesPerPixel = 1] [Row = 256] [Column = 256]" << endl;
					//cout << "program_name 1.input_image.raw 2.ori_image.raw 3.output_image.raw 4.[BytesPerPixel = 1] 5.[Row = 256] 6.[Column = 256]" << endl;

					return 0;
				}
				
				// Check if image is grayscale or color
				if (argc < 3){
					BytesPerPixel = 1; // default is grey image
				} 
				else {
					BytesPerPixel = atoi(argv[3]);
					// Check if size is specified
					if (argc >= 3){
			//			Size = atoi(argv[4]);
						//BytesPerPixel = atoi(argv[3]);
						Row = atoi(argv[4]);
						Column = atoi(argv[5]);
					}
				}
				cout << "Row and Column: " << Row << " and " << Column <<endl;
				cout << "Bytebypixels: " << BytesPerPixel <<endl;
				
				// Allocate image data array
				unsigned char Imagedata[Row][Column][BytesPerPixel];



				// Read image (filename specified by first argument) into image data matrix
				if (!(file=fopen(argv[1],"rb"))) {
					cout << "Cannot open file: " << argv[1] <<endl;
					exit(1);
				}
				fread(Imagedata, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
				fclose(file);
				cout << "Target Image read succeed!" <<endl;


				
				///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////
				long int conditional_mask[40] =  {11111011,11111110,10111111,11101111,10100000,101000,1010,10000010,11000001,1110000,11100,111,11110000,11100001,1111000,111100,11110,1111,10000111,11000011,11110001,1111100,11111,11000111,11100011,11111000,111110,10001111,11110011,11100111,11111100,11111001,1111110,111111,10011111,11001111,11110111,11111101,1111111,11011111};
					
				long int unconditional_mask[444] = {1,100,1000000,10000,10,10000000,1000,100000,10100000,101000,10000010,1010,111000,111001,10111000,10111001,1111000,1111001,11111000,11111001,111010,111011,10111010,10111011,1111010,1111011,11111010,11111011,111100,111101,10111100,10111101,1111100,1111101,11111100,11111101,111110,111111,10111110,10111111,1111110,1111111,11111110,11111111,10000011,11000011,10100011,11100011,10000111,11000111,10100111,11100111,10001011,11001011,10101011,11101011,10001111,11001111,10101111,11101111,10010011,11010011,10110011,11110011,10010111,11010111,10110111,11110111,10011011,11011011,10111011,11111011,10011111,11011111,10111111,11111111,101010,101011,10101010,10101011,1101010,1101011,11101010,11101011,101110,101111,10101110,10101111,1101110,1101111,11101110,11101111,111010,111011,10111010,10111011,1111010,1111011,11111010,11111011,111110,111111,10111110,10111111,1111110,1111111,11111110,11111111,10101000,10101001,11101000,11101001,10101010,10101011,11101010,11101011,10101100,10101101,11101100,11101101,10101110,10101111,11101110,11101111,10111000,10111001,11111000,11111001,10111010,10111011,11111010,11111011,10111100,10111101,11111100,11111101,10111110,10111111,11111110,11111111,10100010,10100011,11100010,11100011,10100110,10100111,11100110,11100111,10101010,10101011,11101010,11101011,10101110,10101111,11101110,11101111,10110010,10110011,11110010,11110011,10110110,10110111,11110110,11110111,10111010,10111011,11111010,11111011,10111110,10111111,11111110,11111111,10001010,10001011,11001010,11001011,10101010,10101011,11101010,11101011,10001110,10001111,11001110,11001111,10101110,10101111,11101110,11101111,10011010,10011011,11011010,11011011,10111010,10111011,11111010,11111011,10011110,10011111,11011110,11011111,10111110,10111111,11111110,11111111,10101,10010100,1010100,10010101,1010101,11010100,11010101,10111,10010110,1010110,10010111,1010111,11010110,11010111,110101,10110100,1110100,10110101,1110101,11110100,11110101,110111,10110110,1110110,10110111,1110111,11110110,11110111,11101,10011100,1011100,10011101,1011101,11011100,11011101,11111,10011110,1011110,10011111,1011111,11011110,11011111,111101,10111100,1111100,10111101,1111101,11111100,11111101,111111,10111110,1111110,10111111,1111111,11111110,11111111,1010100,1010010,1010110,1010001,1010101,1010011,1010111,11010100,11010010,11010110,11010001,11010101,11010011,11010111,1110100,1110010,1110110,1110001,1110101,1110011,1110111,11110100,11110010,11110110,11110001,11110101,11110011,11110111,1011100,1011010,1011110,1011001,1011101,1011011,1011111,11011100,11011010,11011110,11011001,11011101,11011011,11011111,1111100,1111010,1111110,1111001,1111101,1111011,1111111,11111100,11111010,11111110,11111001,11111101,11111011,11111111,1000101,1001001,1001101,1010001,1010101,1011001,1011101,11000101,11001001,11001101,11010001,11010101,11011001,11011101,1000111,1001011,1001111,1010011,1010111,1011011,1011111,11000111,11001011,11001111,11010011,11010111,11011011,11011111,1100101,1101001,1101101,1110001,1110101,1111001,1111101,11100101,11101001,11101101,11110001,11110101,11111001,11111101,1100111,1101011,1101111,1110011,1110111,1111011,1111111,11100111,11101011,11101111,11110011,11110111,11111011,11111111,1000101,100101,1100101,10101,1010101,110101,1110101,11000101,10100101,11100101,10010101,11010101,10110101,11110101,1000111,100111,1100111,10111,1010111,110111,1110111,11000111,10100111,11100111,10010111,11010111,10110111,11110111,1001101,101101,1101101,11101,1011101,111101,1111101,11001101,10101101,11101101,10011101,11011101,10111101,11111101,1001111,101111,1101111,11111,1011111,111111,1111111,11001111,10101111,11101111,10011111,11011111,10111111,11111111,1001010,1001011,1011010,1011011,110001,1110001,110101,1110101,10100100,10100101,10110100,10110101,10010010,11010010,10010110,11010110};


					
				
				
				
				int Imagedata_N[Row][Column][1] ;
				int Imagedata_M[Row][Column][1] ;
				unsigned char Imagedata_output[Row][Column][1];
				
				for(int i = 0; i < Row; i++){
					for(int j = 0; j < Column; j++){
						Imagedata_N[i][j][0] = (int)Imagedata[i][j][0] / 255;

					}
				}
				
				int _flag = 1;
				int iter = 0;
				
				while(_flag==1){
					_flag = 0;
					iter = iter + 1;
			//		cout<<"iter times: "<< iter << endl;
					
					for(int i = 1; i < Row - 1; i++){
						for(int j = 1; j < Column - 1; j++){
							Imagedata_M[i][j][0] = 0;
							long int compare = 10000000*Imagedata_N[i][j+1][0] + 1000000*Imagedata_N[i-1][j+1][0] + 100000*Imagedata_N[i-1][j][0] + 10000*Imagedata_N[i-1][j-1][0] + 1000*Imagedata_N[i][j-1][0] + 100*Imagedata_N[i+1][j-1][0] + 10*Imagedata_N[i+1][j][0] + Imagedata_N[i+1][j+1][0];
							for(int k = 0; k < 40; k++){
								Imagedata_M[i][j][0] = Imagedata_N[i][j][0] && !(compare^conditional_mask[k]);
								if(Imagedata_M[i][j][0]){
									break;
								}
							}
						}
					}
				
					int k;
					for(int i = 1; i < Row - 1; i++){
						for(int j = 1; j < Column - 1; j++){
							int compare = 10000000*Imagedata_M[i][j+1][0] + 1000000*Imagedata_M[i-1][j+1][0] + 100000*Imagedata_M[i-1][j][0] + 10000*Imagedata_M[i-1][j-1][0] + 1000*Imagedata_M[i][j-1][0] + 100*Imagedata_M[i+1][j-1][0] + 10*Imagedata_M[i+1][j][0] + Imagedata_M[i+1][j+1][0];
							for(k = 0; k < 444; k++){
								if(!(compare^unconditional_mask[k])){
									break;
								}
							}
							if(k == 444){
								int temp = Imagedata_N[i][j][0];
								Imagedata_N[i][j][0] = Imagedata_N[i][j][0] && (!Imagedata_M[i][j][0]);
								if (temp != Imagedata_N[i][j][0]){
									_flag = 1;
								}
								
							}
						}
					}
				}
				cout<<"iter times: "<< iter << endl;

				//	briging
				for( int i = 0; i < Row; i++){
					for (int j = 0; j < Column; j++){
						
						int X  = Imagedata_N[i][j][0];
						int X0 = Imagedata_N[i][j+1][0];
						int X1 = Imagedata_N[i-1][j+1][0];
						int X2 = Imagedata_N[i-1][j][0];
						int X3 = Imagedata_N[i-1][j-1][0];
						int X4 = Imagedata_N[i][j-1][0];
						int X5 = Imagedata_N[i+1][j-1][0];
						int X6 = Imagedata_N[i+1][j][0];
						int X7 = Imagedata_N[i+1][j+1][0];
						
						
						int L1 = !X && !X0 &&  X1 && !X2 &&  X3 && !X4 && !X5 && !X6 && !X7;
						int L2 = !X && !X0 && !X1 && !X2 &&  X3 && !X4 &&  X5 && !X6 && !X7;
						int L3 = !X && !X0 && !X1 && !X2 && !X3 && !X4 &&  X5 && !X6 &&  X7;
						int L4 = !X && !X0 &&  X1 && !X2 && !X3 && !X4 && !X5 && !X6 &&  X7;
						
						int PQ = L1 || L2 || L3 || L4;
						
						int P1 = !X2 && !X6 && (X3 || X4 || X5) && (X0 || X1 || X7) && !PQ;
						int P2 = !X0 && !X4 && (X1 || X2 || X3) && (X5 || X6 || X7) && !PQ;
						int P3 = !X0 && !X6 && X7 && (X2 || X3 || X4);
						int P4 = !X0 && !X2 && X1 && (X4 || X5 || X6);
						int P5 = !X2 && !X4 && X3 && (X0 || X6 || X7);
						int P6 = !X4 && !X6 && X5 && (X0 || X1 || X2);
						
						Imagedata_N[i][j][0] = (X || P1 || P2 || P3 || P4 || P5 || P6);

					}
				}

				
				for(int i = 0; i < Row; i++){
					for(int j = 0; j < Column; j++){
						Imagedata_output[i][j][0] = 255 * Imagedata_N[i][j][0];
					}
				}
				
				
				
				////////////////////////// END CODE ////////////////////////////////////////////////


				// Write image data (filename specified by second argument) from image data matrix

				if (!(file=fopen(argv[2],"wb"))) {
					cout << "Cannot open file: " << argv[5] << endl;
					exit(1);
				}
				fwrite(Imagedata_output, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
				fclose(file);

				return 0;
			}
			//(1) Name: Yifei Liu
			//(2) USC ID Number: 3852294243 
			//(3) USC Email: liu534@usc.edu
			//(4) Submission Date: 1/22/2019

			#include <stdio.h>
			#include <iostream>
			#include <stdlib.h>
			#include <cmath>

			using namespace std;

			int convert(float num){

				if(num > 255){
					num = 255;
				}

				if(num < 0){
					num = 0;
				}
				return num;
			}


			int main(int argc, char *argv[])

			{
				// Define file pointer and variables
				FILE *file;
				int BytesPerPixel;
				//int Size = 256;
				int Row;
				int Column;

				
				// Check for proper syntax
				if (argc < 4){
					cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
					cout << "program_name input_image.raw ori_image.raw output_image.raw [BytesPerPixel = 1] [Row = 256] [Column = 256]" << endl;
					//cout << "program_name 1.input_image.raw 2.ori_image.raw 3.output_image.raw 4.[BytesPerPixel = 1] 5.[Row = 256] 6.[Column = 256]" << endl;

					return 0;
				}
				
				// Check if image is grayscale or color
				if (argc < 3){
					BytesPerPixel = 1; // default is grey image
				} 
				else {
					BytesPerPixel = atoi(argv[3]);
					// Check if size is specified
					if (argc >= 3){
			//			Size = atoi(argv[4]);
						//BytesPerPixel = atoi(argv[3]);
						Row = atoi(argv[4]);
						Column = atoi(argv[5]);
					}
				}
				cout << "Row and Column: " << Row << " and " << Column <<endl;
				cout << "Bytebypixels: " << BytesPerPixel <<endl;
				
				// Allocate image data array
				unsigned char Imagedata[Row][Column][BytesPerPixel];



				// Read image (filename specified by first argument) into image data matrix
				if (!(file=fopen(argv[1],"rb"))) {
					cout << "Cannot open file: " << argv[1] <<endl;
					exit(1);
				}
				fread(Imagedata, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
				fclose(file);
				cout << "Target Image read succeed!" <<endl;


				
				///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////
				//1. Expand the image matrix.

				cout << "1. Expand the image matrix." <<endl;
				int N = 3; //Window size
				int i = 0;
				int j = 0;
				int l = 0;
				int k = 0;
				int ch = 0;



				unsigned char Imagedata_Expassion[Row + N - 1][Column + N - 1][BytesPerPixel];

				//fill inside

				for (k = 0; k < BytesPerPixel; k++){

					for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
						for (j = (N - 1)/2; j < Column + (N - 1)/2; j++){

							Imagedata_Expassion[i][j][k] = Imagedata[i - (N - 1)/2][j - (N - 1)/2][k];
						}
					}
				}
				cout << "Fill inside succeed!" <<endl;

				//fill the expended column.

				for (k = 0; k < BytesPerPixel; k++){

					for (i = (N - 1)/2; i < Row + (N - 1)/2; i++){
						for (j = 0; j < (N - 1)/2 ; j++){

							Imagedata_Expassion[i][j][k] = 0;

						}
						for (j = (N - 1)/2 + Column; j < N - 1 + Column; j++){

							Imagedata_Expassion[i][j][k] = 0;
						}
					}
				}
				cout << "Fill the expended column succeed!" <<endl;
				//fill the expeneded row.

				for(k = 0; k < BytesPerPixel; k++){

					for (i = 0; i < (N - 1)/2 ; i++){
						for(j = 0; j < Column + N - 1; j++){

							Imagedata_Expassion[i][j][k] = 0;
						}
					}

					for (i = (N - 1)/2 + Row; i < N - 1 + Row; i++){
						for(j = 0; j < Column + N - 1; j++){

							Imagedata_Expassion[i][j][k] = 0;
						}
					}
				}
				
				
				
				
				
				
				
				
				long int conditional_mask[58] = {1000000,10000,100,1,10000000,100000,1000,10,11000000,1100000,110000,11000,1100,110,11,10000001,11000001,1110000,11100,111,10110000,10100001,1101000,11000010,11100000,111000,1110,10000011,10110001,1101100,11110000,11100001,1111000,111100,11110,1111,10000111,11000011,11110001,1111100,11111,11000111,11100011,11111000,111110,10001111,11110011,11100111,11111100,11111001,1111110,111111,10011111,11001111,11110111,11111101,1111111,11011111};


					
				long int unconditional_mask[364] = {1000000,10000,10,10000000,11000000,1100000,110000,11000,1100,110,11,10000001,1101000,10110000,10100001,11000010,11000100,1100100,11100100,110001,11001,111001,1000110,1001100,1001110,10010001,10011,10010011,111000,111001,10111000,10111001,1111000,1111001,11111000,11111001,111010,111011,10111010,10111011,1111010,1111011,11111010,11111011,111100,111101,10111100,10111101,1111100,1111101,11111100,11111101,111110,111111,10111110,10111111,1111110,1111111,11111110,11111111,101010,1101010,111010,1111010,101010,101011,101110,101111,10100010,10100011,10100110,10100111,10100010,11100010,10110010,11110010,10101000,10101100,10111000,10111100,10101000,10101001,11101000,11101001,10001010,10001011,11001010,11001011,10001010,10001110,10011010,10011110,10101,10010100,10010101,1010100,1010101,11010100,11010101,10111,10010110,10010111,1010110,1010111,11010110,11010111,110101,10110100,10110101,1110100,1110101,11110100,11110101,110111,10110110,10110111,1110110,1110111,11110110,11110111,11101,10011100,10011101,1011100,1011101,11011100,11011101,11111,10011110,10011111,1011110,1011111,11011110,11011111,111101,10111100,10111101,1111100,1111101,11111100,11111101,111111,10111110,10111111,1111110,1111111,11111110,11111111,1010100,1010010,1010110,1010001,1010101,1010011,1010111,11010100,11010010,11010110,11010001,11010101,11010011,11010111,1110100,1110010,1110110,1110001,1110101,1110011,1110111,11110100,11110010,11110110,11110001,11110101,11110011,11110111,1011100,1011010,1011110,1011001,1011101,1011011,1011111,11011100,11011010,11011110,11011001,11011101,11011011,11011111,1111100,1111010,1111110,1111001,1111101,1111011,1111111,11111100,11111010,11111110,11111001,11111101,11111011,11111111,1000101,1001001,1001101,1010001,1010101,1011001,1011101,11000101,11001001,11001101,11010001,11010101,11011001,11011101,1000111,1001011,1001111,1010011,1010111,1011011,1011111,11000111,11001011,11001111,11010011,11010111,11011011,11011111,1100101,1101001,1101101,1110001,1110101,1111001,1111101,11100101,11101001,11101101,11110001,11110101,11111001,11111101,1100111,1101011,1101111,1110011,1110111,1111011,1111111,11100111,11101011,11101111,11110011,11110111,11111011,11111111,1000101,100101,1100101,10101,1010101,110101,1110101,11000101,10100101,11100101,10010101,11010101,10110101,11110101,1000111,100111,1100111,10111,1010111,110111,1110111,11000111,10100111,11100111,10010111,11010111,10110111,11110111,1001101,101101,1101101,11101,1011101,111101,1111101,11001101,10101101,11101101,10011101,11011101,10111101,11111101,1001111,101111,1101111,11111,1011111,111111,1111111,11001111,10101111,11101111,10011111,11011111,10111111,11111111,1001010,1001011,1011010,1011011,101001,1101001,101101,1101101,10100100,10100101,10110100,10110101,10010010,11010010,10010110,11010110,111000,111001,10111000,10111001,1111000,1111001,11111000,11111001,111010,111011,10111010,10111011,1111010,1111011,11111010,11111011,111100,111101,10111100,10111101,1111100,1111101,11111100,11111101,111110,111111,10111110,10111111,1111110,1111111,11111110,11111111};
					
				
				
				
				int Imagedata_N[Row + N - 1][Column + N -1][1] ;
				int Imagedata_M[Row + N - 1][Column + N -1][1] ;
				unsigned char Imagedata_output[Row][Column][1];
				
				for(int i = 0; i < Row + N - 1; i++){
					for(int j = 0; j < Column + N - 1; j++){
						Imagedata_N[i][j][0] = (int)Imagedata_Expassion[i][j][0] / 255;

					}
				}
				
				int _flag = 1;
				int iter = 0;
				
				while(_flag==1){
					_flag = 0;
					iter = iter + 1;
			//		cout<<"iter times: "<< iter << endl;
					for(int i = (N - 1)/2; i < Row + (N - 1)/2; i++){
						for(int j = (N - 1)/2; j < Column + (N - 1)/2; j++){
							Imagedata_M[i][j][0] = 0;
							long int compare = 10000000*Imagedata_N[i][j+1][0] + 1000000*Imagedata_N[i-1][j+1][0] + 100000*Imagedata_N[i-1][j][0] + 10000*Imagedata_N[i-1][j-1][0] + 1000*Imagedata_N[i][j-1][0] + 100*Imagedata_N[i+1][j-1][0] + 10*Imagedata_N[i+1][j][0] + Imagedata_N[i+1][j+1][0];
							for(int k = 0; k < 58; k++){
								Imagedata_M[i][j][0] = Imagedata_N[i][j][0] && !(compare^conditional_mask[k]);
								if(Imagedata_M[i][j][0]){
									break;
								}
							}
						}
					}
				
					int k;
					for(int i = (N - 1)/2; i < Row + (N - 1)/2; i++){
						for(int j = (N - 1)/2; j < Column + (N - 1)/2; j++){
							int compare = 10000000*Imagedata_M[i][j+1][0] + 1000000*Imagedata_M[i-1][j+1][0] + 100000*Imagedata_M[i-1][j][0] + 10000*Imagedata_M[i-1][j-1][0] + 1000*Imagedata_M[i][j-1][0] + 100*Imagedata_M[i+1][j-1][0] + 10*Imagedata_M[i+1][j][0] + Imagedata_M[i+1][j+1][0];
							for(k = 0; k < 364; k++){
								if(!(compare^unconditional_mask[k])){
									break;
								}
							}
							if(k == 364){
								int temp = Imagedata_N[i][j][0];
								Imagedata_N[i][j][0] = Imagedata_N[i][j][0] && (!Imagedata_M[i][j][0]);
								if (temp != Imagedata_N[i][j][0]){
									_flag = 1;
								}
								
							}
						}
					}
				}
				cout<<"iter times: "<< iter << endl;
				
				
				
				
				
			//	detect the dot.
				
				for(int i = (N-1)/2; i < Row + (N - 1)/2; i++){
					for(int j = (N - 1)/2; j < Column + (N - 1)/2; j++){
						Imagedata_output[i][j][0] = 255 * Imagedata_N[i][j][0];
					}
				}
			//	
			//	for(int i = 0; i < Row; i++){
			//		for(int j = 0; j < Column; j++){
			//			
			//			Imagedata_output[i][j][0] = Imagedata[i][j][0];
			//			if(Imagedata_N[i][j][0]){
			//				
			//				long int compare = 10000000*(Imagedata[i][j+1][0]/255) + 1000000*(Imagedata[i-1][j+1][0]/255) + 100000*(Imagedata[i-1][j][0]/255) + 10000*(Imagedata[i-1][j-1][0]/255) + 1000*(Imagedata[i][j-1][0]/255) + 100*(Imagedata[i+1][j-1][0]/255) + 10*(Imagedata[i+1][j][0]/255) + Imagedata[i+1][j+1][0]/255;
			//				if(!(compare^11111111)){
			//					cout << "i : " << i << ", j : " << j << endl;
			//					Imagedata_output[i][j][0] = 255;
			//					
			//				}
			//			}
			//			if(Imagedata[i][j][0] == 0){
			//				if(Imagedata[i][j + 1][0] == 255 && Imagedata[i][j - 1][0] == 255 && Imagedata[i + 1][j][0] == 255 && Imagedata[i - 1][j][0] == 255){
			//					cout << "i : " << i << ", j : " << j << endl;
			//					Imagedata_output[i][j][0] = 255;
			//					
			//				}
			//			}
			//		}
			//	}
				
				

				
				
				
				
				
				////////////////////////// END CODE ////////////////////////////////////////////////


				// Write image data (filename specified by second argument) from image data matrix

				if (!(file=fopen(argv[2],"wb"))) {
					cout << "Cannot open file: " << argv[5] << endl;
					exit(1);
				}
				fwrite(Imagedata_output, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
				fclose(file);

				return 0;
			}
			//(1) Name: Yifei Liu
			//(2) USC ID Number: 3852294243 
			//(3) USC Email: liu534@usc.edu
			//(4) Submission Date: 1/22/2019

			#include <stdio.h>
			#include <iostream>
			#include <stdlib.h>
			#include <cmath>
			#include <queue>

			using namespace std;

			int convert(float num){

				if(num > 255){
					num = 255;
				}

				if(num < 0){
					num = 0;
				}
				return num;
			}


			int main(int argc, char *argv[])

			{
				// Define file pointer and variables
				FILE *file;
				int BytesPerPixel;
				//int Size = 256;
				int Row;
				int Column;

				
				// Check for proper syntax
				if (argc < 4){
					cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
					cout << "program_name input_image.raw ori_image.raw output_image.raw [BytesPerPixel = 1] [Row = 256] [Column = 256]" << endl;
					//cout << "program_name 1.input_image.raw 2.ori_image.raw 3.output_image.raw 4.[BytesPerPixel = 1] 5.[Row = 256] 6.[Column = 256]" << endl;

					return 0;
				}
				
				// Check if image is grayscale or color
				if (argc < 3){
					BytesPerPixel = 1; // default is grey image
				} 
				else {
					BytesPerPixel = atoi(argv[3]);
					// Check if size is specified
					if (argc >= 3){
			//			Size = atoi(argv[4]);
						//BytesPerPixel = atoi(argv[3]);
						Row = atoi(argv[4]);
						Column = atoi(argv[5]);
					}
				}
				cout << "Row and Column: " << Row << " and " << Column <<endl;
				cout << "Bytebypixels: " << BytesPerPixel <<endl;
				
				// Allocate image data array
				unsigned char Imagedata[Row][Column][BytesPerPixel];



				// Read image (filename specified by first argument) into image data matrix
				if (!(file=fopen(argv[1],"rb"))) {
					cout << "Cannot open file: " << argv[1] <<endl;
					exit(1);
				}
				fread(Imagedata, sizeof(unsigned char), Row*Column*BytesPerPixel, file);
				fclose(file);
				cout << "Target Image read succeed!" <<endl;


				
				///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////
				
				// Turn into grayscale
				int Imagedata_Gray[Row][Column][1];
				for (int i = 0; i < Row; i++){
					for(int j = 0; j < Column; j++){
						Imagedata_Gray[i][j][0] = 0.2989 * Imagedata[i][j][0] + 0.5870 * Imagedata[i][j][1] + 0.1140 * Imagedata[i][j][2];
					}
				}
				
				int i = 0;
				int j = 0;
				int intensity_value[256] = {0};
				int Integral[256] = {0};


				for(i = 0; i < Row; i++){
					for(j = 0; j < Column; j++){

						// cout << "intensity_value: " << i << " /" << j <<" is " << intensity_value[(int)Imagedata[i][j][0]] << endl;
						intensity_value[(int)Imagedata_Gray[i][j][0]] = intensity_value[(int)Imagedata_Gray[i][j][0]] + 1;
						
					}
				}
				
				 // functions for output array to be plot
				 FILE *data_f = fopen("histogram_rice.txt", "w");
				 if (data_f == NULL)
				 {
				 	printf("Error opening file!\n");
				 	exit(1);
				 }
				 for (i = 0;i < 256; i++) {
				 	fprintf(data_f, "%d\n", intensity_value[i]);
				 }
				 fclose(data_f);

				
			//	Tune to Binary Image
				double Threshold_1 = 85;

				
				int Imagedata_N[Row][Column][1];
				for (int i = 0; i < Row; i++){
					for (int j = 0; j < Column; j++){
						if (Imagedata_Gray[i][j][0] < Threshold){
							Imagedata_N[i][j][0] = 0;
						}
						else{
							Imagedata_N[i][j][0] = 1;
						}
					}
				}
				
				// erasure the noise
				for (int i = 0; i < Row; i++){
					for (int j = 0; j < Column; j++){
						if (Imagedata_N[i][j][0] == 1){
							long int compare = 10000000*Imagedata_N[i][j+1][0] + 1000000*Imagedata_N[i-1][j+1][0] + 100000*Imagedata_N[i-1][j][0] + 10000*Imagedata_N[i-1][j-1][0] + 1000*Imagedata_N[i][j-1][0] + 100*Imagedata_N[i+1][j-1][0] + 10*Imagedata_N[i+1][j][0] + Imagedata_N[i+1][j+1][0];
							if(!(compare^0) || !(compare^10) || !(compare^1000) || !(compare^100000) || !(compare^10000000)){
								Imagedata_N[i][j][0] = 0;
							}
						}
					}
				}

				
				
				
				
				
				// Connected-component labeling
				queue<int> q_i;
				queue<int> q_j;
				int count[60] = {0};
				
				int Imagedata_label[500][690][1] = {0};
				int label = 1;
				for (int i = 0; i < Row; i++){
					for (int j = 200; j < Column; j++){	
						
						if(Imagedata_N[i][j][0] == 1 && Imagedata_label[i][j][0] == 0){
							Imagedata_label[i][j][0] = label;
							q_i.push(i);
							q_j.push(j);
							
							while(!q_i.empty()){
								int a = q_i.front();
								int b = q_j.front();
								for (int k = -1; k <= 1; k++){
									for(int m = -1; m <= 1; m++){
										if (Imagedata_label[a+k][b+m][0] == 0 && Imagedata_N[a+k][b+m][0] == 1){
											Imagedata_label[a+k][b+m][0] = label;
											q_i.push(a+k);
											q_j.push(b+m);

										}
									}
								}
								q_i.pop();
								q_j.pop();
								count[label] = count[label] + 1;
							}
							
							cout<< "num of " << label << " is :" << count[label] << endl;
							label = label + 1;
							
						}	
					}
				}
				
				
				

				
				// check the label
				data_f = fopen("label_rice.txt", "w");
				 if (data_f == NULL)
				 {
				 	printf("Error opening file!\n");
				 	exit(1);
				 }
				 for (int i = 0; i < Row; i++) {
					for(int j = 0; j < Column; j++){
						fprintf(data_f, "%d\t", Imagedata_label[i][j][0]);

					}
					fprintf(data_f, "\n");
				 }
				 fclose(data_f);
				
				// print label map
				
				unsigned char Imagedata_label_color[Row][Column][1];
				for (int i = 0; i < Row; i++){
					for (int j = 0; j < Column; j++){
						if(Imagedata_label[i][j][0] != 0){
							Imagedata_label_color[i][j][0] = Imagedata_label[i][j][0] * 5;
						}
						else{
							Imagedata_label_color[i][j][0] = 255;
						}
						
					}
				}
				
				
				
				
				
				
			//	output
				unsigned char Imagedata_output[Row][Column][1];
				for(int i = 0; i < Row; i++){
					for(int j = 0; j < Column; j++){
						Imagedata_output[i][j][0] = 255 * Imagedata_N[i][j][0];
					}
				}
				

				
				

				
				
				
				
				
				////////////////////////// END CODE ////////////////////////////////////////////////


				// Write image data (filename specified by second argument) from image data matrix

				if (!(file=fopen(argv[2],"wb"))) {
					cout << "Cannot open file: " << argv[5] << endl;
					exit(1);
				}
				fwrite(Imagedata_output, sizeof(unsigned char), Row*Column*1, file);
				fclose(file);

				return 0;
			}
			clear all;
			% load("label_rice.txt");

			img = imread("rice_threhold_denoise.png");
			% img = rgb2gray(img)
			% clusters = zeros(500*690,3);
			k = 1;
			imgoutput = zeros(500,690);
			for i = 1:500
				for j = 1:690
					if img(i,j) == 255
						clusters(k,:) = [i,j];
						imgoutput(i,j) = img(i,j);
						k = k + 1;
					end
				end
			end



			[IDX, C] = kmeans(clusters, 11);
			for label = 1:11
				size = sum(IDX == label);
				rank(label,:) = [label,size];
			end

			for i = 1:11
				img_1(clusters(find(IDX == i),1),clusters(find(IDX == i),2)) = i * 20;
			end
			imwrite(uint8(img_1),"peer.png")

			% imwrite(uint8(imgoutput),"tune.png")
			% for i = 1
			%     
			%     [x, y] = find(label_rice == i);
			%     
			%     x_c = y - 0.5;
			%     y_c = - x + 500 + 0.5;
			%     
			%     x_means = mean(x_c);
			%     y_means = mean(y_c);
			%     x_var = var(x_c);
			%     y_var = var(y_c);
			%     x_norm = (x_c - x_means)/x_var;
			%     y_norm = (y_c - y_means)/y_var;
			%     
			% %     A = [x_norm,y_norm];
			% %     [U,D,V] = svds(A,1);
			%     s = regress(y_norm,x_norm);
			%     
			% %     Eval = U*D*V';
			%     
			% %     idx1 = min(find(Eval(:,2) == max(Eval(:,2))));
			% %     idx2 = min(find(Eval(:,2) == min(Eval(:,2))));
			%     
			% %     k = (Eval(idx2,2) - Eval(idx1,2))/(Eval(idx2,1) - Eval(idx1,1))
			% %     k = 
			% %     b = y_means - k * x_means + Eval(idx1,2) - k * Eval(idx1,1)
			%     
			%     h = max(x_c) - min(x_c);
			%     
			%     length(i) = sqrt((h*s)^2 + h^2);
			% %     length(i) = sqrt((h*k(1))^2 + h^2)
			%     
			%     %PCA
			% end
			[B,I] = sort(rank(:,2));
				


